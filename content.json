{"pages":[],"posts":[{"title":"关于this的理解","text":"关于this的使用，分为以下三种情况： 显性调用 12345678910111213//方式一function foo(){ console.log(this.a);}var a = 1;foo();//方式二var obj = { a: 2, foo: foo}obj.foo(); 以上两种方式，都属于显性调用，显性调用的this指向的是调用者。 第一种方式中，foo()其实等同于Window.foo(),即Window调用了foo()，所以此时foo()中的this指向的是Window，于是输出的结果是 1。 第二种方式中，obj.foo()的调用者是obj,所以foo()的this指向是obj，于是输出的结果是2。 以上两种方式中，第二种方式的优先级更高，因为它对于调用者的指向更明确，所以obj的同名属性覆盖了window的同名属性。 通过 new 实例化 123var c = new foo();c.a = 3;console.log(c.a); 以上方式通过new实例化了一个对象 c，这种通过new实例化的方式，this会和实例化对象绑定在一起，即this指向的是c。 通过 call、bind、apply 调用 123456function fn(a){ console.log(a);}function Fn(a){ fn.call(this, a);} 以上通过call调用的方式，this指向的就是构造函数本身。","link":"/blog/2020/02/24/about-this/"},{"title":"BFC","text":"BFC 定义BFC 全称 Box Formatting Context的意思，即块级格式化上下文。 BoxBox是 CSS 布局的基本单位，直观的说，一个页面由很多个Box组成。 元素的类型和display属性决定了Box的类型。不同类型的Box会参与不同的Formatting Conetext（一个决定如何渲染文档的容器） Formatting ContextFormatting Context是页面中的一块渲染区域，拥有自己的一套渲染规则。它决定了其子元素如何定位，以及和其他元素之间的关系和相互作用。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块级盒和行内盒都会垂直的沿着其父元素的边框排列。 BFC 的布局规则 内部的Box会在垂直方向，一个接一个地放置； Box垂直方向的距离由margin决定。同属一个BFC的两个相邻Box的margin也会发生重叠； BFC的区域不会和float box重叠； BFC就是页面上一个隔离的独立的容器，容器里面的子元素不会影响到外面的元素，反之亦然； 计算BFC的高度时，其中的浮动元素也参与计算。 如何创建BFC float的值不是none; position的值不是static或者relative； display的值是inline-block、table-cell、flex、table-caption或者inline-flex; overflow的值不是visible。 BFC的作用 利用BFC避免margin重叠 自适应两栏布局 清除浮动 参考链接： 什么是BFC？看这一篇就够了","link":"/blog/2020/02/26/bfc/"},{"title":"使用async&#x2F;await更好的解决异步问题","text":"一、如何使用 async/awaitasync函数是 Generator 的一个语法糖，使用async函数实际上返回的是一个 Promise 对象。如下： 12345678async function fn() { return 30;}// 或者const fn = async () =&gt; { return 30;}; 在声明函数的时候，前面加上关键字**async**即可。我们可以使用 **console.log**打印出上边声明的函数 fn，结果如下： 1234567console.log(fn());// resultPromise = { _proto_: Promise, [[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 30}; 显然，fn 的运行结果其实就是一个 Promise 对象，因此我们可以使用 then 来处理后续逻辑。 123fn().then(res =&gt; { console.log(res);}); await的是含义是等待。意思是代码需要等待await后面的函数运行完成并且有了返回结果之后，才继续执行后续的代码，以此来实现同步的效果。需要注意的是，**await关键字只能在async函数中使用，并且await后面的函数运行后必须返回一个Promise对象才能实现同步的效果**。 当我们使用一个变量去接收await的返回值时，该返回值是 Promise 中 resolve 出来的值（也就是 PromiseValue）。 12345678910111213141516171819202122232425262728293031323334353637// 定一个返回Promise对象的函数function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(3); }, 1000); });}const foo = async () =&gt; { const result_1 = await f1(); console.log(result_1); const result_2 = await f2(); console.log(result_2); const c = await f3(); console.log(result_3);};foo();// 运行结果：// 1// 2// 3 运行这个例子我们可以看出，当在async函数中，运行遇到await时，就会等待await后面的函数运行完毕，而不会直接执行后续程序 二、async/await 相对于直接使用 Promise 的优势如果我们直接使用Promise的话，想要实现以上的结果，就不得不把后续的逻辑写在then方法中。 12345678910111213141516171819202122232425262728293031323334353637function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(3); }, 1000); });}const foo = () =&gt; { return f1() .then(t =&gt; { console.log(t); return f2(); }) .then(t =&gt; { console.log(t); return f3(); }) .then(t =&gt; { console.log(t); });};foo(); ####异常处理在 Promise 中，我们知道是通过 catch 的方式来捕获异常。而当我们使用 async 时，则是通过try/catch来捕获异常。 1234567891011121314151617function fn(){ return new Promise((resolve,reject) =&gt;{ setTimeout(() =&gt;{ reject(&quot;some error.&quot;); },1000) })}const foo = asyn () =&gt;{ try{ await fn(); }catch(e){ console.log(e); //some error. }}foo(); 如果有多个 await 函数，那么只会返回第一个捕获到的异常。 1234567891011121314151617181920212223242526272829303132333435function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f1 error&quot;); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f2 error&quot;); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f3 error&quot;); }, 1000); });}const foo = async () =&gt; { try { await f1(); await f2(); await f3(); } catch (e) { console.log(e); //f1 error }};foo(); 如果我们直接使用Promise，实现以上效果，代码应该写成如下： 1234567891011121314151617181920212223242526272829303132333435363738function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f1 error&quot;); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f2 error&quot;); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f3 error&quot;); }, 1000); });}const foo = () =&gt; { return f1() .then(() =&gt; { return f2(); }) .then(() =&gt; { return f3(); }) .catch(err =&gt; { console.log(err); });};foo(); 很显然，如果使用async/await的话，代码结构会更加简洁，逻辑也更加清晰，更利于项目中的开发以及维护。","link":"/blog/2020/02/24/async-await/"},{"title":"从一道题里说闭包","text":"先看例子 实现一个具有累加器作用的函数，即每次调用函数，调用次数可以累加。 这是一个经典的可以使用闭包实现的函数，正确的写法应该类似于： 函数一 1234567var counter = (function outer() { let count = 0; return function inner() { count ++; return count; }}()) 后来我凭借记忆写了一个错误的函数： 函数二 1234567var counter = function outer() { let count = 0; return (function inner() { count ++; return count; }())} 这两个函数非常相似，一个是外层是自执行函数，一个是内部是自执行函数，并且都用到了闭包，为什么后者却是错误的？ 且看分析： 在第一个函数中，如果我们把外层自执行函数去掉，换成普通函数，那么应该是 1234567var counter = function() { let count = 0; return function() { count ++; return count; }} 可见counter自身是一个函数，执行结果返回了一个函数，即： 1234var outer = counter();var result = outer();// var result = counter()(); 函数一把内层定义的函数inner返回到了外层，并且在外层执行了内层的定义函数。而内层函数inner引用了外层函数outer的变量count，所以当内层函数没有被释放的时候，外层函数也不会被释放，因此外层函数outer内的变量count自然不会被释放。 所以函数一每次执行，计数器count可以累计，不会在每次执行函数时重新定义。 而函数二在函数内部定义了一个函数inner，并且将inner函数执行结果返回到了外层。即，函数inner在outer的内部定义，也在outer的内部执行。所以当函数outer执行的时候，事实上inner已经执行完毕了。因此，即使同样引用了外层变量count，这里却没有发生引用无法释放的问题。 所以函数二每次执行完毕，销毁变量count，每次执行时重新定义，因此无法实现count累计的功能。","link":"/blog/2020/03/06/closure/"},{"title":"手写拷贝函数","text":"拷贝的核心思想，是将目标对象（包括数组）里的每一对键值对，复制到新对象中，最终返回新对象。从而完成了对象的拷贝功能。 拷贝分为深拷贝和浅拷贝两种方式，主要区别在于拷贝过程中，对于引用数据类型的处理。我们知道，如果将一个引用数据类型赋值给一个变量，该变量获取到的是一个引用地址，如果要完成深拷贝，则需要新开辟一个地址空间，用于存储引用地址对应的值。 浅拷贝只复制对象值，不考虑数据类型。 12345678910111213141516class ShallowCopy { constructor (target) { // 判断复制对象的数据类型，如果是基础类型，则直接赋值 if (typeof target !== 'object') return target; // 判断复制对象是数组类型还是普通对象类型 const copy = Array.isArray(target) ? [] : {}; // 遍历复制对象的键值对 for (const key in target) { // 思考这里为什么要判断hasOwnProperty if (target.hasOwnProperty(key)) { copy[key] = target[key]; } } return copy; }} 深拷贝在浅拷贝的基础上，判断所复制的值的类型，如果是引用类型，则新开辟一个地址空间用于存储。 12345678910111213141516171819class DeepCopy { constructor (target) { if (typeof target !== 'object') return target; const copy = Array.isArray(target) ? [] : {}; for (const key in target) { if (target.hasOwnProperty(key)) { const value = target[key]; // 如果是引用数据类型，则递归调用深拷贝 if (value &amp;&amp; typeof value === 'object') { copy[key] = new DeepCopy(value) } else { copy[key] = target[key] } } } return copy }}","link":"/blog/2021/01/25/copy/"},{"title":"Decrator","text":"Decrator Decrator即修饰器，是ES7的一个提案，本质上是一个函数，用来修饰类的行为。 基础1.类修饰器（只有一个参数） target -&gt; 指向类，如果类型是function，则指向Myfunction.prototype 12345678910const animalDecrator = (target) =&gt; { target.isAnimal = true; target.protoType.nickName = 'nimo'};@animalDecratorclass Cat {}console.log(Cat.isAnimal); // trueconsole.log((new Cat()).nickName); // 'nimo' 2.方法修饰器（接受三个参数） target -&gt; 方法所在的类 key -&gt; 方法名称 descriptor -&gt; 描述对象 123456789101112131415const log = (target, key, descriptor) =&gt; { const originFunc = descriptor.value; descriptor.value = (...args) =&gt; { console.log(`${key}:`, args); originFunc.apply(this, args); } return descriptor;};class Utils { @log static setParam (params) {}}Utils.setParams({name: 'lvming'}); // 'setParam: {name: &quot;lvming&quot;}' 修饰器可以传参数，如果需要传参的话，内部需要返回一个方法 123456789101112131415161718const log = (name) =&gt; { return (target, key, descriptor) =&gt; { const originFunc = descriptor.value; descriptor.value = (...args) =&gt; { console.log(`${key} ${name}:`, args); originFunc.apply(this, args); } return descriptor; }}class Utils { @log('hello') static setParam (param) {}}Utils.setParam({name: 'lvming'})// 'setParam hello: {name: &quot;lvming&quot;}' 注意 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升 原理Decrator本质上是利用了ES5的Object.defineProperty特性，通过劫持手段，给方法或属性注入了相关的特性。 执行以下代码 123456789101112131415function readOnly(target, key, descriptor) { descriptor.writable = false; return descriptor;}class Dog { @readOnly bark () { return 'wang wang!!' }}let dog = new Dog();dog.bark = 'miao miao!!';// Cannot assign to read only property 'bark' of [object Object] 本质上是做了如下操作 12345678910class Dog { bark () { return 'wang wang!!' }}Object.defineProperty(Dog.prototype, 'bark', { writable: false}) 应用事件统计 假如我们需要统计页面中每个按钮的点击次数 12345678910111213141516const log = (btn) =&gt; { return (target, key, descriptor) =&gt; { const originFunc = descriptor.value; descriptor.value = (...args) =&gt; { console.log(`按钮${btn}触发了一次`); originFunc.apply(this, args); } return descriptor; }}class MyClass { @log('confirm') handleConfirm () {}}","link":"/blog/2020/04/15/decrator/"},{"title":"Diff算法","text":"Diff算法是Vue的核心之一，通过比较Virtual DOM的方式，只更新新旧节点真正产生差异的部分，而非重新渲染整个DOM结构，从而提升框架性能。 Diff 作用渲染真实DOM需要很大的开销，比如我们修改了某个数据，假如将修改结果直接渲染到真实DOM上，会引起整个DOM结构的重绘和重排序。因此我们需要一种算法，帮助我们实现尽可能只更新真正需要修改的部分，而不是更新整颗DOM树。Diff算法能够实现这样的需求。 Diff 做法我们先根据真实DOM结构生成一颗Virtual DOM，当Virtual DOM某个节点的数据发生变化后，会生成一个新的Vnode，然后将Vnode和oldVnode作对比。 **Vue只会比较Vnode节点，而不是比较DOM**。 因为Vnode是JS对象，不受平台限制，所以以它作为比较基础，代码逻辑后期不需要改动，拿到比较结果后，根据不同平台调用相应的方法进行处理就好了。 Diff 逻辑 Diff比较的内核是节点复用，所以Diff比较就是为了在新旧节点中找到相同节点。 Diff算法只会比较拥有相同父节点的的同级节点，不会进行跨级比较，也不是无限制的递归查找。 什么是拥有相同父节点的同级节点？比如下图出现的 四次比较（从 first 到 fouth），他们的共同特点都是有相同的父节点 比如 蓝色方的比较，新旧子节点的父节点是相同节点1 比如 红色方的比较，新旧子节点的父节点都是2 所以他们才有比较的机会 而下图中，只有两次比较，就是因为在 蓝色方 比较中，并没有相同节点，所以不会再进行下级子节点比较 什么是节点复用？ 节点复用是指新旧节点中，没有产生差异，不需要进行新建或则删除等操作的节点。 节点复用需要满足以下条件： 在旧节点中没有产生差异； 拥有相同的父级节点 属于同一级节点 如下图，在新旧节点树中，节点6拥有相同的父节点8，并且新旧节点中，节点6同属于第三级节点，因此可以满足节点复用的条件。 比如下图，在新旧节点树中，拥有相同的子节点6，但由于前后所属的层级不一样，因此不会产生节点复用。 再如下图，在新旧节点树中，拥有相同的子节点6，并且属于同一层级，但是前后的父节点不一样，也不满足节点复用的条件。 Diff流程图当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。 具体分析 patch 1234567891011121314151617function patch (oldVnode, vnode) { // some code if (sameVnode(oldVnode, vnode)) { patchVnode(oldVnode, vnode) } else { const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) // 父元素 createEle(vnode) // 根据Vnode生成新元素 if (parentEle !== null) { api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null } } // some code return vnode} 12345678910function sameVnode (a, b) { return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 )} 判断两节点是否值得比较，值得比较则执行patchVnode 不值得比较则用Vnode替换oldVnode patchVnode 1234567891011121314151617patchVnode (oldVnode, vnode) { const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) { api.setTextContent(el, vnode.text) }else { updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) { updateChildren(el, oldCh, ch) }else if (ch){ createEle(vnode) //create el's children dom }else if (oldCh){ api.removeChildren(el) } }} 这个函数做了一下事情： 找到对应的真实dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 updateChildren 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869updateChildren (parentElm, oldCh, newCh) { let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (oldStartVnode == null) { // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] }else if (oldEndVnode == null) { oldEndVnode = oldCh[--oldEndIdx] }else if (newStartVnode == null) { newStartVnode = newCh[++newStartIdx] }else if (newEndVnode == null) { newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] }else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newEndVnode)) { patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldEndVnode, newStartVnode)) { patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] }else { // 使用key时的比较 if (oldKeyToIdx === undefined) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 } idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] } else { elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) }else { patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) } newStartVnode = newCh[++newStartIdx] } } } if (oldStartIdx &gt; oldEndIdx) { before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) }else if (newStartIdx &gt; newEndIdx) { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) }} 这个函数做了一下事情： 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 参考链接： 【Vue原理】Diff - 白话版 详解vue的diff算法","link":"/blog/2020/03/01/diff/"},{"title":"事件循环","text":"JS 为什么是单线程？ JS最初设计是应用在浏览器中运行，假如JS是多线程机制，则可能存在这样的情况： 1现有两个线程Process1和Process2，它们同时对同一个Dom节点进行操作，其中Process1删除该Dom节点，而Process2编辑该Dom节点。这是两个矛盾的命令，浏览器将无法运行。 因此，JS需要被设计成单线程。 JS 为什么需要异步？由于JS的单线程机制，决定了其运行顺序自上而下。如果不存在异步，则后边的程序必须等待前边的程序执行完成才可以进行开始运行。如果前边的程序程序运行时间过长，则导致线程阻塞，浏览器可能处在长时间无响应的状态。因此需要异步执行。 JS 如何实现异步？JS是通过事件循环(event loop)来实现异步的，event loop 的机制代表了JS的执行机制。 举个例子： 12345console.log(1);setTimeout(() =&gt; { console.log(2);}, 0);console.log(3); 以上程序的运行结果是：1，3，2。 也就是说，setTimeout 里的函数并没有立即执行，而是延迟了一段时间，在满足一定的条件之后才会执行。这样的代码称为异步代码，反之称为同步代码。 在此可以简单概括JS的运行机制如下（event loop(1)）： 首先判断JS是同步还是异步， 同步任务立即进入主线程，异步任务则进入到event table 异步任务在event table中注册函数，当满足触发条件之后，该任务被推入到event queue中 同步任务会在主线程上一直执行，直到主线程处于空闲状态，此时，主线程会到event quene中查看是否有可执行的任务，如有，则将该任务推入主线程中继续执行 如此反复，称为事件循环 在此对以上例子进行解析： 123456789console.log(1); //任务1，同步任务，进入到主线程里setTimeout(() =&gt; { //任务2，异步任务，进入到event table注册函数，0秒之后被推入event queue中 console.log(2);}, 0);console.log(3); //任务3，同步程序，进入到主线程里主线程在完成了任务1、任务3后，检查event queue是否存在可执行函数，执行setTimeout里的函数。因此最终的输出结果是1-3-2。 在此需要注意的是，异步任务的执行需要两个条件： 满足触发条件 主线程空闲 因此，将函数体setTimeout(() =&gt; fn(), 3000)解释为“定时器在 3 秒之后执行 fn”并不准确，准确的解释应该是： 13秒后，fn被推入到event queue，当主线程空闲时，fn从event quene推入到主线程中执行 正因如此，我们并不能完全依赖 setTimeout 作为一个定时器，对于setTimeout(() =&gt; fn(), 3000)，如果主线程需要运行 10 秒，则 fn 实际上是 13 秒后才开始运行。 再看一个例子： 12345678910setTimeout(() =&gt; console.log(1), 0);new Promise(resolve =&gt; { resolve(2); console.log(3);}).then((res) =&gt; { console.log(res);});console.log(4); 假如我们利用之前的知识去分析： 12345678910setTimeout(() =&gt; console.log(1), 0); //任务1，异步任务，进入event table注册，0秒后进入event queuenew Promise(resolve =&gt; { //任务2，同步任务，其中包含 resolve(2); console.log(3); //任务3，同步任务}).then((res) =&gt; { //任务4，异步任务，在event table注册后进入event queue，排在任务1之后 console.log(res);});console.log(4); //任务5，同步任务 根据此分析，最终的输出结果是：3-4-1-2 这是正确的输出结果吗？程序执行之后，得到的最终结果应该是：3-4-2-1 是否因为异步任务的执行顺序不是前后顺序而另有规定，导致输出结果与我们预知的不一样？ 事实上，单纯的按照异步和同步的划分方式，并不准确。 准确的划分方式是： macro-task(宏任务)：包括整体代码 script,setTimeout,setInterval micro-task(微任务)：Promise, process.nextTick 按照这样的分类方式，JS 的执行机制是（event loop(2)）： 执行一个宏任务，过程中如果遇到微任务，就将其放在微任务的【事件队列】里 当前宏任务执行完成后，会查看微任务的【事件队列】，并将其中的全部微任务执行完成 重复以上 2 步骤，结合 event loop(1)和 event loop(2),就可以得到更准确的 JS 执行机制。 此时我们再去分析刚刚出错的列子： 1234561.首先执行script下的宏任务，遇到setTimeout,将其放在宏任务的【队列】里2.遇到 new Promise直接执行，里边的同步任务cosnole.log(3)立即触发3.遇到 then 方法，是微任务，将其放在微任务的【队列】里4.遇到console.log(4)直接执行。5.当主线程完成cosnole.log(3)和console.log(4)后，会去检查微任务的【队列】,发现其中的任务 then,于是执行console.log(res),此处的res === 2;6.当微任务完成之后，会去检查宏任务【队列】，发现setTimeout,并执行","link":"/blog/2020/02/24/event-loop/"},{"title":"flex布局","text":"Flex布局是什么？Flex是Flexible Box的缩写，意为弹性布局，用来为盒子模型提供最大的灵活性。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称“容器”。它的所有子元素称为容器成员（flex item），简称“项目”。 容器默认存在两根轴：水平得分主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据主轴的空间叫做main size，占据交叉轴的空间叫做cross size。 容器的属性以下6个属性设置在容器上。 123456* flex-direction* flex-wrap* flex-flow* justify-content* align-items* align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box { flex-direction: row | row-reverse | column | column-reverse} 它可能有4个值: 1234* row（默认值）：主轴为水平方向，起点在左端。* row-reverse：主轴为水平方向，起点在右端。* column：主轴为垂直方向，起点在上沿。* column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条轴线上，flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box { flex-wrap: nowrap | wrap | wrap-reverse} 它可能有3个取值: 123* nowrap（默认值）：不换行。* wrap：换行，第一行在上方。* wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction和flex-wrap属性的简写形式，默认值为row nowrap。 123.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;} justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 1234.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右: 12345* flex-start（默认值）：左对齐。* flex-end：右对齐。* center：居中。* space-between：两端对齐，项目之间的间隔都相等。* space-around：每个项目的两侧间隔相等。所以项目之间的间隔比项目与边框的间隔大一倍。 tips: space-around 属性不可实现项目等分排列 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 12345* flex-start：交叉轴的起点对齐。* flex-end：交叉轴的终点对齐。* center：交叉轴的中心对齐。* baseline：项目第一行文字的基线对齐。* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 该属性可能取6个值： 123456* flex-start：与交叉轴的起点对齐。* flex-end：与交叉轴的终点对齐。* center：与交叉轴的中点对齐。* space-between：与交叉轴的两端对齐，轴线之间的间隔平均分布。* space-around：每根轴线两侧分间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍。* stretch（默认值）：轴线占满整个交叉轴。 项目属性以下6个属性设置在项目上： 123456* order* flex-grow* flex-shrink* flex-basis* flex* align-self order属性order属性定义项目分排列顺序。数值越小。排列越靠前，默认为0. 123.item { order: &lt;integer&gt;;} flex-grow属性flex-grow属性定义项目的放大比例，默认是0，即如果存在剩余空间，也不放大。 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认是1，即如果空间不足，该项目将缩小。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值是auto，即项目的本来大小。 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flex属性flex属性是flex-grow、flex-shrink和flex-basic简写，默认为0 1 auto。后两个属性可选。 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-self属性align-self属性允许单个项目有其他项目不一样的对齐方式，可覆盖align-items属性。默认值是auto，表示继承了父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","link":"/blog/2020/02/27/flex/"},{"title":"函数声明与函数表达式的区别","text":"先看一个例子 12345678910111213function fn(flag) { if (flag) { function getValue() { return &quot;a&quot;; } } else { function getValue() { return &quot;b&quot;; } } return getValue();} 对于函数声明，解析器会率先读取并且让其在执行任何代码前可用，意思就是别的代码还没有运行的时候，被声明的函数已经被读取了，效果相当于 123456789101112function fn(flag) { function getValue() { return &quot;a&quot;; } function getValue() { return &quot;b&quot;; } if (flag) { } else { } return getValue();} 如此，后边声明的函数会覆盖前边声明的函数。 而对于函数表达式，解析器只有执行到它所在的位置时才会真正地去解释和执行，因此可用函数表达式来修复这个问题。 12345678910111213function fn(flag) { if (flag) { var getValue = function() { return &quot;a&quot;; }; } else { var getValue = function() { return &quot;b&quot;; }; } return getValue();}","link":"/blog/2020/02/24/function-declaration/"},{"title":"如何使用Hexo和Github Pages搭建个人博客","text":"什么是 Hexo? Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 如何安装? 安装前提: 安装Node.js 安装Git安装教程 开始安装： 全局安装 Hexo $ npm install -g hexo-cli 使用 Hexo工具初始化一个项目 hexo init blog 进入到初始化后的项目，并下载安装包 cd blog &amp; npm install 使用 Hexo 启动项目 hexo server tips: hexo 安装完成后，最好使用 hexo -v命令检查是否安装成功，题主在使用npm安装时，可能由于个人电脑环境的关系，导致hexo没有写入全局环境里，所以一直无法使用hexo命令，最后使用yarn安装解决了该问题，读者也可以从环境变量的角度去解决问题。 hexo 安装成功后，可能项目会因为缺少模版文件导致在启动项目后页面无法显示的问题，不要轻易放弃，继续往下看即可。 安装主题挑选你喜欢的主题风格，在项目根目录下进行安装 如： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 安装完成后，项目根目录中会生成themes文件夹，用于存放主题，然后通过根目录下的_config.yml文件进行主题配置 1theme: your theme 将your theme改成你的主题名字，主题名字应该与themes目录下的文件夹名字保持一致。 主题即模版，因此安装完成主题之后，一般能够解决缺少模板而导致的问题，此时应该可以顺利启动项目了。 借助 GitHub Pages 部署自己的博客项目 新建 GitHub 仓库 tips: 如何新建 github 仓库不在本教程的教学之内。 新建仓库时，请确保仓库权限是public而非private，题主开始在新建仓库的时候选择了private，导致后续的Github Pages配置一直遇到问题，项目部署后却无法打开网址 保存新生成的仓库地址 打开上文提到的_config.yml进行配置 1234deploy: type: git repo: git@github.com:yourgithub.github.io.git branch: master tips: 找过deploy关键字开始配置； repo 后配置的是新建仓库时生成的仓库地址； 所有冒号之后都有一个空格。 安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 安装该插件后，可以使用以下命令： hexo clean hexo g hexo d 其中： hexo clean 用于清除上次打包后的模板 hexo g 用于打包模板 hexo d 用于部署项目 项目部署地址即为我们在上文中的deploy配置的地址 打开 github 项目地址，即可访问在线博客 tips: 部署项目后，线上访问内容可能存在十分轴左右的延迟，并非及时更新。 参考链接： Hexo 使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 轻松搞定 GitHub Pages 超详细Hexo+Github Page搭建技术博客教程","link":"/blog/2020/02/24/hexo/"},{"title":"Hello Hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/blog/2020/02/23/hello-hexo/"},{"title":"HTTP那些事","text":"http的基本优化影响一个http网络请求的因素主要有两个：带宽和延迟。 带宽：拨号上网的阶段，带宽可能会是一个严重影响请求的问题，但是现代网络基础建设的优化使得带宽不再成为影响网速的问题； 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。对于同一个域名，PC浏览器一般可以同时支持4～6个连接，手机浏览器则更少，超过浏览器最大连接数限制时，后续请求就会被阻塞，这也是为什么当请求量大的时候，可以将资源部署多台服务器或则使用CDN进行优化的原因。 DNS查询（DNS Lookup）：浏览器需要知道目标服务器的IP地址才能建立连接。**将域名解析成IP地址的这个系统就是DNS**。如果每次连接都经过DNS解析是一个很耗时的过程，通常可以利用DNS缓存来减少解析所消耗的时间。 建立连接（Initial Connection）：**HTTP是基于TCP协议的**，浏览器最快也要在完成三次握手后才能捎带HTTP请求报文，实现建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响明显，慢启动则对大文件类型的请求影响较大。 HTTP1.0和HTTP1.1的一些区别 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since、Expires来作为缓存的判断标准，HTTP1.1则引入了更多的缓存控制策略，比如Entity Tag、If-Unmodified-Since、If-Match、 If-None-Match等更多的请求头来控制缓存策略； 带宽优化和网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理：在HTTP1.0中认为每台服务器都绑定唯一的IP地址，因此请求消息中的URL并没有传递主机名（hostname），随着虚拟主机技术的发展，一台物理服务器可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1请求消息和响应消息都支持Host头域，且请求消息中如果没有Host头域会报告错误（400 Bad Request）。 长连接：HTTP1.1支持长连接（PersistenConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立连接和关闭连接的消耗和延迟，**在HTTP1.1中默认开启Connection：keep-alive**，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 HTTPS和HTTP的一些区别 HTTPS协议需要到CA申请证书； HTTP协议运行在TCP之上，所有传输的内容都是明文的，HTTPS运行在SSL/TSL之上，SSL/TSL运行在TCP之上，所有的传输内容都经过加密； HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80端口，后者是443端口； HTTPS可以有效解决劫持问题。 什么是SPDYSPDY是Google在2012年提出的方案，优化HTTP1.X的请求延迟，解决了HTTP1.X的安全性问题，具体如下： 降低延迟：SPDY采用了多路复用的方式，通过多个请求stream共享一个TCP连接，解决了HOL blocking的问题，降低了延迟，同时提高了带宽的利用率； 请求优先：**SPDY允许给每一个请求设置优先级**，这样重要的请求就会优先得到响应； header压缩： 选择合适的压缩算法可以减少包的大小和数量； 基于HTTPS的加密协议传输，提高数据传输的可靠性； 服务端推送（server push）：当客户端像服务端请求一个文件的时候，服务端可以将客户端后续可能需要的文件也推送给它，当客户端再次尝试获取该文件的时候，就可以直接从缓存中获取，不用再发请求。 SPDTY位于HTTP之下，TCP和SSL之上，这样可以方便兼容老版本的的HTTP协议，并且可以使用已有的SSL 功能。 TCP ——&gt;SSL——&gt;SPDY——&gt;HTTP HTTP2.0HTTP2.0可以说是SPDY的升级版（原本基于SPDY）设计，所以包含以上提到的SPDY优点：**降低延迟、请求优先、header压缩、多路复用、服务端推送**等，但是和SPDY依然存在区别： HTTP2.0支持明文传输，而SPDY强制使用HTTPS加密传输 HTTP2.0消息头的压缩算法采用的是HPACK，而SPDY采用的是DEFLATE","link":"/blog/2020/02/24/http/"},{"title":"import和require的区别","text":"import和require都是用于模块化引入，是模块化编程的功能。 遵循规则 require是AMD规范的引入方式 import是es6的一个语法标准 调用时间 require是运行时调用，所以require理论上可以运用在代码的任何地方 import是编译时调用，一般放在文件开头（import命令具有提升效果，会提升到整个模块的头部，所以并不是必须写在开头） 本质 require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量 import是解构的过程，对于没有实现import的引擎，使用babel转译后，import的语法会转码成require 导出 require/exports: 遵循CommonJS/AMD的规则，只能在运行时确定模块的依赖关系以及输入/输出的变量，无法进行静态化处理。 node的module遵循CommonJS规范 requireJS遵循AMD规范 seaJS遵循CMD规范 用法如下： 123const fs = require('fs');exports.fs = fs;module.exports = fs; import/export: 遵循es6规范，支持编译时静态分析，便于引入宏和类型校验，动态绑定。 用法如下： 1234567891011import fs from 'fs';import {default as fs} from 'fs';import * as fs from 'fs';import {readFile} from 'fs';import {readFile as read} from 'fs';import fs, {readFile} from 'fs';export default fs;export const fs;export function readFile;export {readFile, read}; 总结 通过require引入基础数据类型时，属于复制该变量； 通过require引入复杂数据类型时，数据浅拷贝该对象； 出现模块之间的循环引用时，会输出已经执行的模块，而未执行的模块不输出； CommonJS模块默认export的是一个对象，即使导出的是基础数据类型。","link":"/blog/2020/07/23/import-require/"},{"title":"继承的实现方式","text":"函数对象的继承写在前边，先创建一个父类，用于后边的继承。代码如下： 12345678910111213// 定义一个动物类function Animal(name) { //属性 this.name = name || &quot;Animal&quot;; //实例方法 this.sleep = function() { console.log(`${this.name} is sleeping`); };}//原型方法Animal.prototype.eat = function(food) { console.log(`${this.name} is eating ${food}`);}; 原型链继承核心：将父类的实例作为子类的原型 12345678function Cat() {}Cat.prototype = new Animal(&quot;cat&quot;);var cat = new Cat();console.log(cat.name); // 'cat';console.log(cat.sleep); // 'cat is sleeping'console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 因为重定向了子类的原型指向，所以要为子类新增属性和方法，必须在new Animal()这样的语句后执行，不能放在构造器里 因为只能指向一个原型，所以无法实现更多的继承 来自原型对象的所有属性都被所有实例继承 创建子类实例时，无法向父类构造器传参 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类 12345678910function Cat(name) { Animal.call(this); this.name = name || &quot;Tom&quot;;}var cat = new Cat(&quot;cat&quot;);console.log(cat.name); //'cat'console.log(cat.sleep()); //'cat is sleeping'console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); //true 特点： 解决了 1 中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承(可以 call 多个父类对象) 缺点： 实例并非父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性和方法 无法实现函数的复用，每个子类都有父类的实例函数的副本，影响性能 实例继承核心：为父类添加新特性，作为子类的实例返回 12345function Cat(name) { var instance = new Animal(); instance.name = name || &quot;Tom&quot;; return instance;} 特点： 不限调用的方式，不管是new Cat()还是Cat()，返回的对象都具有相同的效果 缺点： 实例时父类的实例，不是子类的实例 不支持多继承 拷贝继承核心：遍历父类的原型属性，在子类的原型上添加父类原型的副本 1234567891011function Cat(name) { var animal = new Animal(); for (var p in animal) { Cat.prototype[p] = animal[p]; } Cat.prototype.name = name || &quot;Tom&quot;;}var cat = new Cat();console.log(cat instanceof Animal); //falseconsole.log(cat instanceof Cat); //true 特点： 可以实现多继承 缺点： 效率较低，内存占用高(因为要拷贝父类的属性) 无法获取父类不可枚举的方法(因为不可枚举的方法，无法在for in遍历中访问到) 组合继承核心：通过调用父类的构造，继承了父类的属性并保留传参，然后通过将父类实例作为子类原型，实现函数的复用 12345678910function Cat(name) { Animal.call(this); this.name = name || &quot;Tom&quot;;}Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat = new Cat();console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 弥补了方式 2 中的缺陷，可以继承实例属性方法，也可以继承原型属性和方法 既是子类的实例，也是父类的实例 不存在引用属性的共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例(子类实例将子类原型上的那份给遮蔽了) 寄生继承核心：通过寄生方式，砍掉了父类的实例属性，在调用两次父类的构造的时候，就不会初始化两次实例属性和方法，避免了组合继承的缺点 1234567891011121314function Cat(name){ Animal.call(this); this.name = name || 'Tom'；}(function(){ var Super = function(){}; Super.prototype = Animal.prototype; Cat.prototype = new Super()})();Cat.prototype.constructor = Cat;var cat = new Cat();console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 普通对象的继承Object()方法核心：将子对象的 prototype 属性指向父对象，从而将子对象和父对象连接起来 1234567function Object(o) { function F() {} F.prototype = o; return new F();}var Child = Object(Parent); 浅拷贝核心：将父对象的所有属性拷贝给子对象 123456789function extendCopy(p) { var c = {}; for (var i in p) { c[i] = p[i]; } return c;}var Child = extendCopy(Parent); 缺点：如果父对象的属性类型是数组或对象，那么实际上，子对象获得的只是一个内存地址，当子对象对该属性进行修改，也会影响到该属性在父对象上的值 深拷贝核心：递归调用‘浅拷贝’，将父对象的所有属性深度拷贝给子对象，而非指针的指向关系 1234567891011121314function deepCopy(p, c) { var c = c || {}; for (var i in p) { if (typeof p[i] === &quot;Object&quot;) { c[i] = p[i].constructor === Array ? [] : {}; deepCopy(p[i], c[i]); } else { c[i] = p[i]; } } return c;}var Child = deepCopy(Parent);","link":"/blog/2020/02/24/inheritance-prototype/"},{"title":"Intersection Observer","text":"简介概念 IntersectionObserver接口提供一种异步观察目标元素与其祖先元素或顶级文档视图(viewport)交叉状态的方法。祖先元素与视图(viewport)被称为**根(root)**。 构造器IntersectionObserver() 创建一个新的IntersectionObserver对象，当其监听到目标元素的可见部分穿过一个或多个**阀(thresholds)**时，会执行指定的回调函数。 属性 threshold：决定什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 root：用于观察的根元素，默认是浏览器的视口，也可以指定具体元素，指定元素的时候用于观察的元素必须是指定元素的子元素。 rootMargin： 用来扩大或者缩小视窗的的大小，使用css的定义方法，10px 10px 30px 20px表示top、right、bottom 和 left的值。 方法 **disconnect()**：使IntersectionObserver对象停止监听工作。 **observe()**：使IntersectionObserver对象开始监听一个元素。 **takeRecords()**：返回所有观察目标的IntersectionObserverEntry对象数组。 **unobserve()**：使IntersectionObserver停止监听特定目标元素。 Intersection Observers示例IntersectionObserver懒加载（vue单文件组件简版）123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;img v-for=&quot;(image, i) in images&quot; :key=&quot;i&quot; src :data-img-url=&quot;image&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { images: [ 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247890587&amp;di=88d4066be3d57ac962a6bec37e265d37&amp;imgtype=0&amp;src=http%3A%2F%2F01.imgmini.eastday.com%2Fmobile%2F20170810%2F20170810151144_d41d8cd98f00b204e9800998ecf8427e_3.jpeg', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=4054762707,1853885380&amp;fm=26&amp;gp=0.jpg', 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247912077&amp;di=508a949e5e291875debf6ca844292cd4&amp;imgtype=0&amp;src=http%3A%2F%2F03imgmini.eastday.com%2Fmobile%2F20180827%2F20180827095359_6759372e9bd28026ee6f53b500fb4291_2.jpeg', ], }; }, mounted() { const images = document.querySelectorAll('img'); const observerLazyLoad = new IntersectionObserver((entries) =&gt; { entries.forEach((item) =&gt; { if (item.isIntersecting) { item.target.src = item.target.dataset.imgUrl; } }); }); images.forEach((image) =&gt; { observerLazyLoad.observe(image); }); },};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;img { display: block; height: 500px; margin: 30px;}&lt;/style&gt; IntersectionObserver吸顶（vue单文件组件简版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;p class=&quot;fixed-top-helper&quot;&gt;&lt;/p&gt; &lt;p class=&quot;fixed-top-reference&quot;&gt;&lt;/p&gt; &lt;header&gt;头部&lt;/header&gt; &lt;main&gt; &lt;img v-for=&quot;(image, i) in images&quot; :key=&quot;i&quot; :src=&quot;image&quot; /&gt; &lt;/main&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { images: [ 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247890587&amp;di=88d4066be3d57ac962a6bec37e265d37&amp;imgtype=0&amp;src=http%3A%2F%2F01.imgmini.eastday.com%2Fmobile%2F20170810%2F20170810151144_d41d8cd98f00b204e9800998ecf8427e_3.jpeg', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=4054762707,1853885380&amp;fm=26&amp;gp=0.jpg', 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247912077&amp;di=508a949e5e291875debf6ca844292cd4&amp;imgtype=0&amp;src=http%3A%2F%2F03imgmini.eastday.com%2Fmobile%2F20180827%2F20180827095359_6759372e9bd28026ee6f53b500fb4291_2.jpeg', ], }; }, mounted() { const header = document.querySelector('header'); const fixedTopReference = document.querySelector('.fixed-top-reference'); fixedTopReference.style.top = `${header.offsetTop}px`; const observerFixedTop = new IntersectionObserver((entries) =&gt; { entries.forEach((item) =&gt; { if (item.boundingClientRect.top &lt; 0) { header.classList.add('fixed'); } else { header.classList.remove('fixed'); } }); }); observerFixedTop.observe(fixedTopReference); },};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.fixed-top-helper { height: 1px; background: #ccc;}header { background: #ccc; &amp;.fixed { position: fixed; top: 0; left: 0; width: 100%; }}main { img { display: block; height: 500px; margin: 30px; }}&lt;/style&gt; tips: * fixedTopReference是为了避免缓慢移动时add remove .fixed死循环，死循环的结果是抖动 * fixedTopHelper是为了避免被吸顶元素没有上一个sibling元素（也就是说被吸顶元素是最上层元素）时，避免缓缓移动时add remove .fixed死循环抖动，特殊引入的标签，需要设置1个px的height * fixedTopHelper需要与被吸顶元素保持样式一致，以确保好的用户体验。例如在本例中将其background设置为#ccc，很好的做到了隐藏 IntersectionObserver触底（vue单文件组件简版）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div&gt; &lt;main&gt; &lt;img v-for=&quot;(image, i) in images&quot; :key=&quot;i&quot; src=&quot;image&quot; /&gt; &lt;/main&gt; &lt;footer&gt;底部&lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { images: [ 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247890587&amp;di=88d4066be3d57ac962a6bec37e265d37&amp;imgtype=0&amp;src=http%3A%2F%2F01.imgmini.eastday.com%2Fmobile%2F20170810%2F20170810151144_d41d8cd98f00b204e9800998ecf8427e_3.jpeg', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=4054762707,1853885380&amp;fm=26&amp;gp=0.jpg', 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247912077&amp;di=508a949e5e291875debf6ca844292cd4&amp;imgtype=0&amp;src=http%3A%2F%2F03imgmini.eastday.com%2Fmobile%2F20180827%2F20180827095359_6759372e9bd28026ee6f53b500fb4291_2.jpeg', ], }; }, mounted() { const footer = document.querySelector('footer'); const observerTouchBottom = new IntersectionObserver((entries) =&gt; { entries.forEach((item) =&gt; { if (item.isIntersecting) { setTimeout(() =&gt; { console.log('滚动到了底部，可以发request请求数据了'); }, 2000); } }); }); observerTouchBottom.observe(footer); },};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;main { img { display: block; height: 500px; margin: 30px; }}footer { background: #ccc;}&lt;/style&gt; 参考链接： Intersection Observer 90行代码，15个元素实现无限滚动 IntersectionObserver是什么？","link":"/blog/2020/02/29/intersection-observer/"},{"title":"MutationObserver","text":"简介 MutationObserver接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。 概念Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。 概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。 构造函数使用时，首先使用MutationObserver构造函数，新建一个观察器实例，同时指定这个实例的回调函数。 1const observer = new MutationObserver(callback); 上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。 123456const observer = new MutationObserver((mutations, observer) =&gt; { mutations.forEach((mutation) =&gt; { console.log(mutation); });}); 方法 observe() observe方法用来启动监听，它接受两个参数。 第一个参数：所要观察的DOM节点 第二个参数：一个配置对象，指定所要观察的特定变动 12345678const article = document.querySelector('article');const options = { 'childList': true, 'attributes':true} ;observer.observe(article, options); 上面代码中，observe方法接受两个参数，第一个是所要观察的DOM元素是article，第二个是所要观察的变动类型（子节点变动和属性变动）。 观察器所能观察的 DOM 变动类型（即上面代码的options对象），有以下几种。 childList：布尔值，表示子节点的变动（指新增，删除或者更改）。 attributes：布尔值，表示属性的变动。 characterData：布尔值，表示节点内容或节点文本的变动。 subtree：布尔值，表示是否将该观察器应用于该节点的所有后代节点。 attributeOldValue：布尔值，表示观察attributes变动时，是否需要记录变动前的属性值。 characterDataOldValue：布尔值，表示观察characterData变动时，是否需要记录变动前的值。 attributeFilter：数组，表示需要观察的特定属性（比如['class','src']）。 tips: 想要观察哪一种变动类型，就在 option 对象中指定它的值为 true。需要注意的是，必须同时指定 childList、attributes 和 characterData 中的一种或多种，若均未指定将报错。 下面的例子是观察新增的子节点。 123456789let insertedNodes = [];const observer = new MutationObserver((mutations) =&gt; { mutations.forEach((mutation) =&gt; { for (var i = 0; i &lt; mutation.addedNodes.length; i++) insertedNodes.push(mutation.addedNodes[i]); })});observer.observe(document, { childList: true });console.log(insertedNodes); takeRecords() takeRecords方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。 1observer.takeRecords(); disconnect() disconnect方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。 1observer.disconnect(); MutationRecord 对象DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个MutationRecord实例所组成的数组。 MutationRecord对象包含了DOM的相关信息，有如下属性： type：观察的变动类型（attribute、characterData或者childList）。 target：发生变动的DOM节点。 addedNodes：新增的DOM节点。 removedNodes：删除的DOM节点。 previousSibling：前一个同级节点，如果没有则返回null。 nextSibling：下一个同级节点，如果没有则返回null。 attributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。 oldValue：变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。 应用示例子元素的变动下面的例子说明如何读取变动记录。 123456789101112131415let callback = function (records){ records.map((record) =&gt; { console.log('Mutation type: ' + record.type); console.log('Mutation target: ' + record.target); });};const mo = new MutationObserver(callback);const option = { 'childList': true, 'subtree': true};mo.observe(document.body, option); 上面代码的观察器，观察&lt;body&gt;的所有下级节点（childList表示观察子节点，subtree表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。 属性的变动下面的例子说明如何追踪属性的变动。 1234567891011121314151617const callback = function (records) { records.map((record) =&gt; { console.log('Previous attribute value: ' + record.oldValue); });};const mo = new MutationObserver(callback);const element = document.getElementById('#my_element');const options = { 'attributes': true, 'attributeOldValue': true}mo.observe(element, options); 上面代码先设定追踪属性变动（'attributes': true），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。 实现水印的不可删除 在实现水印不可删除的过程中，主要需要应对的逻辑有两个： 监听对水印节点的修改 监听对水印节点的删除 监听对水印节点的修改 12345678910111213drawCanvas () { ... ... // 代码省略}canvasObserver() { this.drawCanvas(); let canvasObserver = new MutationObserver((mo) =&gt; { this.drawCnvas(); }); let config = { attributes: true, childList: true, characterData: true }; canvasObserver.observe(document.querySelector('#divContainer'), config);} 监听对水印节点的删除 12345678910111213141516171819drawCanvas () { ... ... // 代码省略}canvasObserver() { this.drawCanvas(); let canvasObserver = new MutationObserver((mo) =&gt; { let { removedNodes } = mo[0]; if (removedNodes.find(target)) { ... ... // 寻找目标节点的伪代码 this.drawCnvas(); } }); let config = { attributes: true, childList: true, characterData: true }; let target = document.querySelector('#divContainer'); canvasObserver.observe(target.parentNode, config);} 参考链接： Mutation Observer API","link":"/blog/2020/02/29/mutation-observer/"},{"title":"进程和线程","text":"进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的的基本单位，是操作系统的基础，是程序是的实体，是线程的容器。 线程 线程（thread）是程序执行的最小的单位 线程是进程的一个实体，是被系统调度和分派的基本单位 线程不拥有系统资源，它与同属一个进程的其他线程共享进程所拥有的全部资源 一个线程可以创建和撤销另一个线程，同一个进程的多个线程之间可以并发执行 由于线程之间的互相制约，致使线程在运行中呈现出间断性 一个标准的线程包括：线程ID、当前指令指针（PC）、寄存器集合、 堆栈 线程包含就绪、阻塞、运行三种状态 进程和线程的区别 地址空间和其他资源：进程间相互独立，同一进程的各个线程共享资源。某进程内的线程在其他进程不可见。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 调度和切换：线程上下文切换比进程上下文切换要快很多。 在多线程OS中，进程不是一个可执行的实体。 多进程和多线程的比较 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用IPC；数据是分开的，同步简单 共享进程数据，共享简单，同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应多核、多机分布式；如果一台及其不够，扩展到多台机器比较简单 适应多核分布式 进程占优 通信进程间的通信进程间通信是指在不同进程之间传播或交换信息。IPC(InterProcess Communication)的方式通常有管道、消息队列、信号量、共享存储、Socket、Streams等。其中Socket和Streams支持不同主机上的两个进程IPC。 管道： 速度慢，容量有限，只有父子进程能通讯； FIFO： 任何进程都能通讯，但速度慢； 消息队列： 容量收到系统限制，且要注意第一次读的时间，要考虑上一次没有读完数据的问题； 信号量：不能传递复杂消息，只能用来同步； 共享内存区： 能够狠容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。 线程间的通信 使用全局变量（窗体不适用） 使用自定义消息（窗体适用） 使用事件内核对象 并发与并行并发在操作系统中，并发是指一个时间段中有几个程序都处于已经启动运行到运行完毕的状态之间，且这几个程序都是在同一个处理机上运行。其中并发关系可以分为两种： 互斥： 进程间互相排斥的使用临界资源的现象，称为互斥； 同步： 进程间不排斥使用临界资源，而是相互依赖，前一个进程的输出作为后一个进程的输入，当前一个线程没有输出时，第二个线程必须等待。 并行在单处理器的多道程序设计系统中，进程被交替执行，表现出一种并发的外部特征； 在多处理器系统中，进程不仅可以交替执行，还可以重叠执行。在多处理器上的程序才可以实现并行处理。 从而可知，并行是针对多处理器而言的，并行是同时发生多个并发事件，具有并发的含义，但并发并不一定并行，或说并发事件之间不以帝国要同一时刻发生。","link":"/blog/2020/07/20/process-thread/"},{"title":"Proxy","text":"Proxy是ES6新增的一种操作对象的API，用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 语法 let p = new Proxy(target, handler); 参数 target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 方法Proxy有13种数据劫持的操作。 方法 描述 get 获取某个key值 set 设置某个key值 has 使用in操作符判断某个key是否存在 apply 函数调用，仅在代理对象为function时有效 ownKeys 获取目标对象所有的key construct 函数通过实例话调用，仅在代理对象为function时有效 isExtensible 判断对象是否可扩展 deleteProperty 删除某一个property defineProperty 定义一个新的property getPrototypeOf 获取原型对象 setPrototypeOf 设置原型对象 preventExtensions 设置对象为不可扩展 getOwnPropertyDescriptor 获取一个自有属性(非原型连上的属性)的属性描述 get get方法是你在得到某个对象属性值时预处理的方法，接受两个常用参数 target：得到的目标值 key：对象的属性 12345678910111213141516let Bao = { name: 'LV', price: 9999};let proxy = new Proxy(Bao, { get: function (target, key) { if (target['price'] &gt; 5000) { return '超出客户心理价位' } else { return '符合客户心理价位' } }});proxy.price; // 超出客户心理价位 set set方法用来拦截某个属性的赋值操作，可以接受四个参数 target: 目标值 key: 对象属性 value: 对象属性值 receiver: 改变前的原始值 12345678910111213141516171819202122let validator = { set: function(target, key, value) { if (key === 'age') { if (!Number.isInteger(value)) { throw new TypeError('The age is not an integer'); } if (value &gt; 200) { throw new RangeError('The age seems invalid'); } } target[key] = value; }};let person = new Proxy({}, validator);person.age = 100;person.age; // 100person.age = 'young' // he age is not an integerperson.age = 300 // The age seems invalid Proxy相比Object.defineProperty的优势 支持数组 123456789101112131415161718let arr = [1,2,3]let proxy = new Proxy(arr, { get (target, key, receiver) { console.log('get', key) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log('set', key, value) return Reflect.set(target, key, value, receiver) }})proxy.push(4)// 能够打印出很多内容// get push (寻找 proxy.push 方法)// get length (获取当前的 length)// set 3 4 (设置 proxy[3] = 4)// set length 4 (设置 proxy.length = 4) 针对对象 与Object.defineProperty()方法不同，Proxy针对的是完整的对象，而不是对象的某个属性，所以不需要对keys进行遍历。 1234567891011121314151617let obj = { name: 'Eason', age: 30}let handler = { get (target, key, receiver) { console.log('get', key) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log('set', key, value) return Reflect.set(target, key, value, receiver) }}let proxy = new Proxy(obj, handler)proxy.name = 'Zoe' // set name Zoeproxy.age = 18 // set age 18 嵌套支持 Proxy本质上是不支持嵌套的。可以通过在get方法里边递归调用Proxy来实现。 123456789101112131415161718192021222324let obj = { info: { name: 'eason', blogs: ['webpack', 'babel', 'cache'] }}let handler = { get (target, key, receiver) { console.log('get', key) // 递归创建并返回 if (typeof target[key] === 'object' &amp;&amp; target[key] !== null) { return new Proxy(target[key], handler) } return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log('set', key, value) return Reflect.set(target, key, value, receiver) }}let proxy = new Proxy(obj, handler)// 以下两句都能够进入 setproxy.info.name = 'Zoe'proxy.info.blogs.push('proxy') 应用实例使用Proxy实现表单校验 123456789101112131415161718let person = { name: 'xiaoming', age: 30}let handler = { set (target, key, value, receiver) { if (key === 'name' &amp;&amp; typeof value !== 'string') { throw new Error('用户姓名必须是字符串类型') } if (key === 'age' &amp;&amp; typeof value !== 'number') { throw new Error('用户年龄必须是数字类型') } return Reflect.set(target, key, value, receiver) }}let boy = new Proxy(person, handler)boy.name = 'xiaohong' // OKboy.age = '18' // 报错 用户年龄必须是数字类型 参考链接： Proxy ES6-Proxy与数据劫持","link":"/blog/2020/03/04/proxy/"},{"title":"JS原型与原型链","text":"普通对象与函数对象凡是通过 new Function()创建的对象都是函数对象，其他的是普通对象。 123456789101112131415161718var o1 = {};var o2 =new Object();var o3 = new f1();function f1(){};var f2 = function(){};var f3 = new Function('str','console.log(str)');console.log(typeof Object); //functionconsole.log(typeof Function); //functionconsole.log(typeof f1); //functionconsole.log(typeof f2); //functionconsole.log(typeof f3); //functionconsole.log(typeof o1); //objectconsole.log(typeof o2); //objectconsole.log(typeof o3); //object 以上例子中，o1、o2、o3 均为普通对象(实例对象)，f1、f2、f3 均为函数对象(抽象对象) 构造函数任何一个实例都有一个constructor（构造函数）属性，该属性（是一个指针）指向了实例的构造函数。即实例的 constructor === 构造函数 12345678910function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name); };}var person1 = new Person(&quot;Zaxlct&quot;, 28, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Mick&quot;, 23, &quot;Doctor&quot;); 123console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //true 原型对象每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性。函数对象的 prototype 指向函数的原型对象。换而言之,只有函数对象才存在原型对象，函数对象的 prototype 属性指向了其原型对象。 举个例子 123function Person() {}Person.prototype.name = &quot;linlin&quot;;Person.prototype.age = 25; 以上代码完全等价于 12345function Person() {}Person.prototype = { name: &quot;linlin&quot;, age: 25}; 由于函数对象的 prototype 属性指向的是其原型对象，而上述例子中，Person.prototype 指向的是一个普通对象{name: 'linlin', age: 25}，由此我们可知，原型对象是一个普通函数。 所有的原型对象都有一个constructor（构造函数）属性，这个属性是一个指针，指向prototype属性所在的函数。 即 1Person.prototype.constructor == Person 联系之前知识，实例的 constructor === 构造函数，在此我们可以将 Person.prototype 当成 Person 的一个实例 person1，于是以上代码可看作是等价如下: 1person1.constructor == Person; 也就是在 Person 创建的时候，创建了一个它的实例化对象并且赋值给它的 prototype，基本过程如下： 12var A = new Person();Person.prototype = A; 结论：原型对象(Person.prototype)是构造函数(Person)的一个实例。 原型对象的主要作用是用于继承。所有定义在原型对象上的属性，都可以被构造函数实例化的对象继承。 __proto__JS 在创建对象的时候，不管是普通对象还是函数对象，都会内置一个叫做**__proto__**的属性，用于指向创建它的构造函数的原型对象。 12var person = new Person();person._proto_ === Person.prototype; 需要注意的是，这种指向关系存在于实例(person)和构造函数的原型对象(Person.prototype)之间，而非实例(person)于构造函数(Person)之间。 PrototypePrototype是保存一个函数对象所有方法的真正存在，换句话说，当我们定一个函数对象的时候，该函数对象的所有方法和属性其实是保存在该对象的prototype属性上，而非存在于函数本身。以下例子可以说明： 123456789101112131415function Person(age) { this.name = &quot;person&quot;; this.age = age;}Person.prototype.sex = &quot;male&quot;;var p = new Person(10);console.log(Person.name); //undifinedconsole.log(Person.age); //undifinedconsole.log(Person.sex); //undifinedconsole.log(p.name); //'person'console.log(p.age); //10console.log(p.sex); //'male' 可以看出，我们无法直接获取到函数对象的任何属性，是因为所有属性存在于函数对象的prototype属性上，而非存在于函数本身，而使用实例对象直接访问到函数对象的所有属性，这是因为实例对象的__proto__属性指向的是其构造函数的是原型对象，即构造函数的prototype，通过原型链就可以访问到prototype上的所有属性。 原型链当查找一个实例的属性时，会先从这个实例的自定义属性上查找，如果没有的话，会通过__proto__去实例所属的类的原型（实例的构造函数）上找，如果还没有的话，就会通过原型的__proto__到Object的原型上去找，如此层层往上，直到__proto__指向的是 null。这种通过__proto__在对象之间构成的关系，就称为原型链。 如果实例和原型都共存一个相同的属性，在访问该属性时，指向的是实例上的属性，而非原型上的属性，这种情况称为属性遮蔽。如下 1234567891011121314function Fn() { this.a = 1; this.b = 2;}Fn.prototype.b = 3;Fn.prototype.c = 4;var f = new Fn();console.log(f.a); // a是自身属性，该属性的值为1console.log(f.b); // b是自身属性，该属性的值为2，原型上也有属性'b'，但由于“属性遮蔽”所以无法访问console.log(f.c); // c不是自身属性，会通过原型链往它的原型上去查找，而原型上有属性‘c’,该属性的值为4console.log(f.d); // d不是自身属性，会通过 原型链是指对象之间通过__proto__建立起来的指向关系，所以原型链的形成依靠的是__proto__,而非prototype","link":"/blog/2020/03/04/prototype/"},{"title":"Reflect","text":"ES6中将Object的一些明显属于语言内部的方法移植到了Reflect对象上，未来的心方法只部署在Reflect对象上。 Reflect对象对某些方法的返回结果进行了修改，使其更合理。 Reflect对象使用函数的方式实现了Object的命令式操作。 为什么使用Reflect1. 更有用的返回值Reflect对象的方法调用结果是一个Boolean值，不会像Object的方法一样返回obj。 我们可以对如下代码进行重构： 123456try {Object.defineProperty(obj, name, desc); // property defined successfully} catch (e) { // possible failure (and might accidentally catch the wrong exception)} 重构成这样： 12345if (Reflect.defineProperty(obj, name, desc)) { // success} else { // failure} 2. 更好的操作方式Reflect对象帮我们封装好了一些常用方法，像Math对象一样，我们可以可以直接调用其静态方法。 如: 12345// 删除属性delete obj[name]// 判断属性是否存在name in obj 可以改写成: 12345// 删除属性Reflect.deleteProperty(obj, name)// 判断属性是否存在Reflect.has(obj, name) 3.更可靠的函数时执行方式在ES5中，如果要执行一个函数f，并且传给它一组参数args，还要绑定this的话，通常这样写： 1f.apply(obj, args) 但是f的apply方法可能被重新定义了，所以比较可靠的写法是： 1Function.prototype.apply.call(f, obj, args) 上面这段代码太长，显得不够优雅，我们可以使用Reflect更简洁的实现： 1Reflect.apply(f, obj, args) 4. 可变参数形式的构造函数在ES5中，实例化函数方法如下： 1var obj = new F(...args) 或者 1var obj = F.apply(this, args) 不过ES5不支持扩展符，并且当F是一个构造函数的时候，就会显得捉襟见肘。 但是在ES6中我们可以这样写： 1let obj = Reflect.construct(F, args) 5. 控制访问起活着读取器的this在ES5中，读取或设置属性需要这样做： 12var name = obj['name']; // 读取属性obj['name'] = 'Jerry' // 设置属性 我和可以使用Reflect.set()方法实现同样的事情，并且增加而外的参数recover，这样允许我们设置对象的setter和getter的上下文this： 12345678910111213141516171819var obj = { set foo(value) { return this.bar(); }, bar: function() { alert(1); }};var wrapper = { bar: function() { console.log(&quot;wrapper&quot;); }}Reflect.set(obj, &quot;foo&quot;, &quot;value&quot;, wrapper);// 当我们设置 foo 属性的时候，触发了 this.bar() 函数// 此时的 this 指向了 wrapper// 所以触发的是 wrapper.bar() 函数// 因此输出结果是 'wrapper' 6. 避免直接访问__proto__我们可以使用Reflect.getPrototypeOf(obj) 和 Reflect.setPrototypeOf(obj, newProto)方法去访问和设置对象的原型 方法Reflect对象的方法和Proxy对象的方法一一对应，所以Proxy对象的方法可以通过调用Reflect对象的方法取默认行为，然后进行额外操作。 方法 描述 get 获取某个key值 set 设置某个key值 has 使用in操作符判断某个key是否存在 apply 函数调用，仅在代理对象为function时有效 ownKeys 获取目标对象所有的key construct 函数通过实例话调用，仅在代理对象为function时有效 isExtensible 判断对象是否可扩展 deleteProperty 删除某一个property defineProperty 定义一个新的property getPrototypeOf 获取原型对象 setPrototypeOf 设置原型对象 preventExtensions 设置对象为不可扩展 getOwnPropertyDescriptor 获取一个自有属性(非原型连上的属性)的属性描述 参考链接： ES6 Reflect与Proxy Javascript中Reflect对象详解","link":"/blog/2020/03/05/reflect/"},{"title":"十大经典排序","text":"冒泡排序 算法简介冒泡排序是一种简单的的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的排序错误就交换它们的位置。走访数列的工作是重复地进行直到没有需要交换，也就是说数列已经完成排序了。这个算法的名字由来是因为越小的元素就经由交换慢慢的“浮”到数列的顶端。 算法描述 比较相邻的元素，如果第一个比第二个大，就交换它们的位置； 对每一对相邻的元素作同样的工作，从第一对到结尾的最后一对，理论上在最后的元素应该是最大的数； 针对所有元素重复以上的步骤，除了最后一个(因为每次循环中，最后一个数都是最大的数)； 重复步骤 1 ～ 3，直到排序完成。 算法实现1234567891011function bubbleSort(arr) { let len = arr.length; for (let i = 0; i &lt; len; i++) { for (let j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr;} tips: 设置一标志位pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后非记录均已交换到位，故在进行下一趟排序时只要扫描到pos的位置即可。 改进后的算法如下： 123456789101112131415function bubbbleSort2(arr) { let i = arr.length - 1; //初始时，最后位置保持不变 while (i &gt; 0) { let pos = 0; //每趟开始时，无记录交换 for (let j = 0; j &lt; i; j++) { if (arr[j] &gt; arr[j + 1]) { pos = j; // 记录交换位置 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } i = pos; } } s; return arr;} tips: 传统冒泡排序中，每一趟排序操作只能找到一个最大值或最小值，我们可以利用在每趟排序中进行正向和反向两遍冒泡的方法一次得到两个最终值（最大值和最小值），从而使循环次数几乎减少一半。 改进后的算法如下： 123456789101112131415161718192021222324252627282930313233function bubbleSort3(arr) { let low = 0; let high = arr.length - 1; let j; while(low &lt; high) { for (j=low; j&lt;high; ++j) { // 正向冒泡，找最大值 if（arr[j] &gt; arr[j+1]）{ [ arr[j], arr[j+1] ] = [ arr[j+1], arr[j] ] } -- high; } for (j=high; j&gt;low; --j) { if (arr[j] &lt; arr[j-1]) { [ arr[j], arr[j-1] ] = [ arr[j-1], arr[j] ] } ++ low; } } return arr;} 算法分析 最佳情况：T(n) = O(n) 当输入的数据已经是正序时 最差情况：T(n) = O(n2) 当输入的数据是反序时 平均情况：T(n) = O(n2) 选择排序算法简介选择排序是一种简单直观的排序算法，也是表现最稳定的排序算法之一。它的工作原理：首先在未排序序列中找到最小的元素，存放到排序序列的起始位置，然后再从剩余的未排序元素中继续寻找最小元素，然后放在已排序元素的末尾。以此类推，知道所有元素均排序完毕。 算法描述n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为 R[1,…n]，有序区为空； 第 i 趟排序(i=1,2,3,…n-1)开始时，当前有序区和无序区分别为 R[1,…i-1]和 R[i,…n]。该趟排序从当前无序区中选出关键字最小记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1,…i]和 R[i+1,…n]分别为记录个数增加 1 哥的新有序区和记录个数减少一个的新无序区； 重复步骤 2，n-1 趟结束，得到有序数组。 算法实现1234567891011121314function selectionSort(arr) { let len = arr.length; let minIndex, temp; for (let i = 0; i &lt; len - 1; i++) { minIndex = i; for (let j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { minIdex = j; } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } return arr;} 算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 插入排序算法简介插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序(即只需用到 O(1)的额外空间的排序)，因而在从后向前的扫描过程中，需要反复把已排序的元素逐步向后挪位，为最新元素提供插入空间。 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可认为是已排序元素； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序元素）大于新元素，将新元素移到下一位置； 重复步骤 3，直到找到已排序元素小于或则等于新元素的位置； 将新元素插入到该位置； 重复步骤 2 ～ 5. 算法实现123456789101112function insertionSort(arr) { for (let i = 1; i &lt; arr.length; i++) { let key = arr[i]; let j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } return arr;} tips: 查找插入位置时使用二分查找可以提高效率 1234567891011121314151617181920function binaryInsertionSort(arr) { for (let i = 1; i &lt; arr.length; i++) { let key = arr[i]; let left = 0; let right = i - 1; while (left &lt;= right) { let middle = parserInt((left + right) / 2); if (key &lt; arr[middle]) { right = middle - 1; } else { left = middle + 1; } } for (let j = i - 1; j &gt;= left; j--) { arr[j + 1] = arr[j]; } arr[left] = key; } return arr;} 算法分析 最佳情况：T(n) = O(n2) 输入数组按升序排序 最差情况：T(n) = O(n2) 输入数组按降序排序 平均情况：T(n) = O(n2)","link":"/blog/2020/02/24/sorting/"},{"title":"什么是虚拟DOM","text":"虚拟DOM的本质是用js对象来表示页面上的元素，并提供了操作DOM对象的API DOM树的概念一个网页的呈现过程： 浏览器请求服务器获取页面的HTML结构； 浏览器在内存中，解析DOM结构，并且在浏览器内存中渲染出一颗DOM树； 浏览器把DOM树呈现在页面上。 虚拟DOM虚拟DOM指的是用js对象的形式，来模拟页面上DOM的嵌套关系。 例如： 1234&lt;div id=&quot;name&quot; title=&quot;name&quot;&gt; hello world &lt;p&gt;i am coming&lt;/p&gt;&lt;/div&gt; 对应的虚拟DOM是： 123456789101112131415const div = { tagName: 'div', attrs: { id: 'name', title: 'name' }, children: [ 'hello world', { tagName: 'p', attrs: {}, children: ['i am coming'] } ]} 为什么需要虚拟DOM在React、Vue等技术出现之前，我们要改变页面展示的内容，只能通过遍历查询DOM树的方式来找到需要修改的DOM，然后修改样式、行为或则结构，以此来达到更新UI的目的。 这种方式非常消耗计算资源，原因有二： DOM树的实现模块和JS模块是分开的，跨模块的通讯增加了成本； DOM操作会因此浏览器的回流和重绘,增加渲染成本。 我们可以将DOM模块和JS模块比喻成两个目的地，中间有一条桥梁将二者连接，每实现一次JS模块对DOM模块的操作，都需要交一次过桥费。因此这样的操作越多，代价越大。 虚拟DOM渲染示例 创建一个虚拟DOM: 12345678910111213141516171819202122const HelloWorld = { nodeName:'div', attrs:{ className:'', }, css:{ width: '100px', height: '40px', color: 'green' }, events:{ onclick:()=&gt;{ console.log('Hello virtual DOM') } }, childrens:[ { nodeName:'text', attrs:{ innerText:'HelloWorld', }, } ]} 解析虚拟DOM 12345678910111213141516171819202122232425262728293031function render(vNode) { // 创建dom const dom = document.createElement(vNode.nodeName) const { attrs, css, events, childrens } = vNode // 添加属性 for(const attrName in attrs){ dom[attrName] = attrs[attrName] } // 添加行内样式 for(const attrName in css){ dom.style[attrName] = css[attrName] } // 添加事件 for(const eventName in events){ dom[eventName] = events[eventName] } if(childrens){ for(const children of childrens) { // 生成子节点 const childrenNode = render(children) // 绑定子节点 dom.append(childrenNode) } } return dom} 渲染虚拟DOM 12const dom = render(HelloWorld)document.body.append(dom) 参考链接： 什么是虚拟DOM","link":"/blog/2020/03/01/virtual-dom/"},{"title":"vuex和redux的区别","text":"流向vuex的流向 同步操作： view -&gt; commit -&gt; mutations -&gt; state变化 -&gt; view变化 异步操作：view -&gt; dispatch -&gt; actions -&gt; mutations -&gt; state变化 -&gt; view变化 redux的流向同步异步一样：view -&gt; actions -&gt; reducer -&gt; state变化 -&gt; view变化 Redux相对于Flux的改进 把store和dispatcher合并，结构更加简单清晰。新增state角色，代表每个时间点store对应的值，最状态的管理更加明确； 整个数据管理框架只有一个store Vuex与Redux的区别 改进了redux中的action和reducer函数，以mutations变化函数取代了reducer，无需switch，只需要在对应的mutations函数里改变state值的变化； 由于vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state即可； vuex数据流的顺序是：view调用store.commit提交对应的请求到store中对应的mutation函数 -&gt; store更新（vue检测到数据变化自动渲染）","link":"/blog/2020/07/23/vuex-redux/"}],"tags":[{"name":"this","slug":"this","link":"/blog/tags/this/"},{"name":"css","slug":"css","link":"/blog/tags/css/"},{"name":"BFC","slug":"BFC","link":"/blog/tags/BFC/"},{"name":"async&#x2F;await","slug":"async-await","link":"/blog/tags/async-await/"},{"name":"es6","slug":"es6","link":"/blog/tags/es6/"},{"name":"闭包","slug":"闭包","link":"/blog/tags/%E9%97%AD%E5%8C%85/"},{"name":"拷贝","slug":"拷贝","link":"/blog/tags/%E6%8B%B7%E8%B4%9D/"},{"name":"decator","slug":"decator","link":"/blog/tags/decator/"},{"name":"vue","slug":"vue","link":"/blog/tags/vue/"},{"name":"react","slug":"react","link":"/blog/tags/react/"},{"name":"diff","slug":"diff","link":"/blog/tags/diff/"},{"name":"event-loop","slug":"event-loop","link":"/blog/tags/event-loop/"},{"name":"flex","slug":"flex","link":"/blog/tags/flex/"},{"name":"function","slug":"function","link":"/blog/tags/function/"},{"name":"hexo","slug":"hexo","link":"/blog/tags/hexo/"},{"name":"blog","slug":"blog","link":"/blog/tags/blog/"},{"name":"http","slug":"http","link":"/blog/tags/http/"},{"name":"继承","slug":"继承","link":"/blog/tags/%E7%BB%A7%E6%89%BF/"},{"name":"intersection","slug":"intersection","link":"/blog/tags/intersection/"},{"name":"滚动加载","slug":"滚动加载","link":"/blog/tags/%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/"},{"name":"MutationObserver","slug":"MutationObserver","link":"/blog/tags/MutationObserver/"},{"name":"水印不可删除","slug":"水印不可删除","link":"/blog/tags/%E6%B0%B4%E5%8D%B0%E4%B8%8D%E5%8F%AF%E5%88%A0%E9%99%A4/"},{"name":"计算机","slug":"计算机","link":"/blog/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"proxy","slug":"proxy","link":"/blog/tags/proxy/"},{"name":"reflect","slug":"reflect","link":"/blog/tags/reflect/"},{"name":"算法","slug":"算法","link":"/blog/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/blog/tags/%E6%8E%92%E5%BA%8F/"},{"name":"virtual dom","slug":"virtual-dom","link":"/blog/tags/virtual-dom/"}],"categories":[{"name":"JS基础","slug":"JS基础","link":"/blog/categories/JS%E5%9F%BA%E7%A1%80/"},{"name":"CSS","slug":"CSS","link":"/blog/categories/CSS/"},{"name":"Vue","slug":"Vue","link":"/blog/categories/Vue/"},{"name":"教程","slug":"教程","link":"/blog/categories/%E6%95%99%E7%A8%8B/"},{"name":"HTTP","slug":"HTTP","link":"/blog/categories/HTTP/"},{"name":"Web开发技术","slug":"Web开发技术","link":"/blog/categories/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"计算机","slug":"计算机","link":"/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"算法","slug":"算法","link":"/blog/categories/%E7%AE%97%E6%B3%95/"}]}