{"pages":[],"posts":[{"title":"关于this的理解","text":"关于this的使用，分为以下三种情况： 显性调用 12345678910111213//方式一function foo(){ console.log(this.a);}var a = 1;foo();//方式二var obj = { a: 2, foo: foo}obj.foo(); 以上两种方式，都属于显性调用，显性调用的this指向的是调用者。 第一种方式中，foo()其实等同于Window.foo(),即Window调用了foo()，所以此时foo()中的this指向的是Window，于是输出的结果是 1。 第二种方式中，obj.foo()的调用者是obj,所以foo()的this指向是obj，于是输出的结果是2。 以上两种方式中，第二种方式的优先级更高，因为它对于调用者的指向更明确，所以obj的同名属性覆盖了window的同名属性。 通过 new 实例化 123var c = new foo();c.a = 3;console.log(c.a); 以上方式通过new实例化了一个对象 c，这种通过new实例化的方式，this会和实例化对象绑定在一起，即this指向的是c。 通过 call、bind、apply 调用 123456function fn(a){ console.log(a);}function Fn(a){ fn.call(this, a);} 以上通过call调用的方式，this指向的就是构造函数本身。","link":"/2020/02/24/about-this/"},{"title":"Asset Module","text":"Asset Module(资源模块)是webpack5新增的一种模型类型，它允许使用资源文件（字体、图标等）而无需配置额外的loader。 在webpack5之前，通常使用： raw-loader 将文件导入为字符串 url-loader 将文件作为data URI内联到bundle中（如把小图片转换成base64） file-loader 将文件发送到输出目录 资源模块类型（asset module type），通过添加4种新的模块类型，来替换所有这些loader： asset/resource 发送一个单独的文件并导出URL。之前通过使用file-loader实现。 asset/inline 导出一个资源的data URI。之前通过url-loader实现。 asset/source 导出资源的源代码。之前通过raw-loader实现。 asset 在导出一个data URI和发送一个单独的文件之间自动选择（即在asset/resouce和asset/inline之间自动切换）。 用代码说话： webpack4 123456789101112131415161718192021222324{ module: { rules: [ ..., { test: /\\.(jpe?g|png|gif)$/i, // 图片文件 use: [ { loader: 'url-loader', options: { limit: 10240, fallback: { loader: 'file-loader', options: { name: 'img/[name].[hash:8].[ext]' } } } } ] } ] }} webpack5 12345678910111213141516{ module: { rules: [ ..., { test: [/\\.bmp$/, /\\.gif$/, /\\.jpe?g$/, /\\.png$/], type: 'asset', parser: { dataUrlCondition: { maxSize: 1024 } } } ] }} 以上两个配置都实现了同一个功能，即当资源文件大小在限定范围内，则导出其data URI，转换成内联文件，否则导出独立文件。 webpack4使用了url-loader和file-loader两个loader来实现，先尝试使用url-loader转换成内联文件，如果文件大小不符合限制条件，则进一步使用file-loader。 而webpack5没用使用任何loader，仅添加type: 'asset'属性，就完成了内联文件和独立文件之前的切换。","link":"/2021/04/02/asset-module/"},{"title":"使用async&#x2F;await更好的解决异步问题","text":"一、如何使用 async/awaitasync函数是 Generator 的一个语法糖，使用async函数实际上返回的是一个 Promise 对象。如下： 12345678async function fn() { return 30;}// 或者const fn = async () =&gt; { return 30;}; 在声明函数的时候，前面加上关键字**async**即可。我们可以使用 **console.log**打印出上边声明的函数 fn，结果如下： 1234567console.log(fn());// resultPromise = { _proto_: Promise, [[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 30}; 显然，fn 的运行结果其实就是一个 Promise 对象，因此我们可以使用 then 来处理后续逻辑。 123fn().then(res =&gt; { console.log(res);}); await的是含义是等待。意思是代码需要等待await后面的函数运行完成并且有了返回结果之后，才继续执行后续的代码，以此来实现同步的效果。需要注意的是，**await关键字只能在async函数中使用，并且await后面的函数运行后必须返回一个Promise对象才能实现同步的效果**。 当我们使用一个变量去接收await的返回值时，该返回值是 Promise 中 resolve 出来的值（也就是 PromiseValue）。 12345678910111213141516171819202122232425262728293031323334353637// 定一个返回Promise对象的函数function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(3); }, 1000); });}const foo = async () =&gt; { const result_1 = await f1(); console.log(result_1); const result_2 = await f2(); console.log(result_2); const c = await f3(); console.log(result_3);};foo();// 运行结果：// 1// 2// 3 运行这个例子我们可以看出，当在async函数中，运行遇到await时，就会等待await后面的函数运行完毕，而不会直接执行后续程序 二、async/await 相对于直接使用 Promise 的优势如果我们直接使用Promise的话，想要实现以上的结果，就不得不把后续的逻辑写在then方法中。 12345678910111213141516171819202122232425262728293031323334353637function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(1); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(2); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(3); }, 1000); });}const foo = () =&gt; { return f1() .then(t =&gt; { console.log(t); return f2(); }) .then(t =&gt; { console.log(t); return f3(); }) .then(t =&gt; { console.log(t); });};foo(); ####异常处理在 Promise 中，我们知道是通过 catch 的方式来捕获异常。而当我们使用 async 时，则是通过try/catch来捕获异常。 1234567891011121314151617function fn(){ return new Promise((resolve,reject) =&gt;{ setTimeout(() =&gt;{ reject(&quot;some error.&quot;); },1000) })}const foo = asyn () =&gt;{ try{ await fn(); }catch(e){ console.log(e); //some error. }}foo(); 如果有多个 await 函数，那么只会返回第一个捕获到的异常。 1234567891011121314151617181920212223242526272829303132333435function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f1 error&quot;); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f2 error&quot;); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f3 error&quot;); }, 1000); });}const foo = async () =&gt; { try { await f1(); await f2(); await f3(); } catch (e) { console.log(e); //f1 error }};foo(); 如果我们直接使用Promise，实现以上效果，代码应该写成如下： 1234567891011121314151617181920212223242526272829303132333435363738function f1() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f1 error&quot;); }, 1000); });}function f2() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f2 error&quot;); }, 1000); });}function f3() { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { reject(&quot;f3 error&quot;); }, 1000); });}const foo = () =&gt; { return f1() .then(() =&gt; { return f2(); }) .then(() =&gt; { return f3(); }) .catch(err =&gt; { console.log(err); });};foo(); 很显然，如果使用async/await的话，代码结构会更加简洁，逻辑也更加清晰，更利于项目中的开发以及维护。","link":"/2020/02/24/async-await/"},{"title":"BFC","text":"BFC 定义BFC 全称 Box Formatting Context的意思，即块级格式化上下文。 BoxBox是 CSS 布局的基本单位，直观的说，一个页面由很多个Box组成。 元素的类型和display属性决定了Box的类型。不同类型的Box会参与不同的Formatting Conetext（一个决定如何渲染文档的容器） Formatting ContextFormatting Context是页面中的一块渲染区域，拥有自己的一套渲染规则。它决定了其子元素如何定位，以及和其他元素之间的关系和相互作用。 BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块级盒和行内盒都会垂直的沿着其父元素的边框排列。 BFC 的布局规则 内部的Box会在垂直方向，一个接一个地放置； Box垂直方向的距离由margin决定。同属一个BFC的两个相邻Box的margin也会发生重叠； BFC的区域不会和float box重叠； BFC就是页面上一个隔离的独立的容器，容器里面的子元素不会影响到外面的元素，反之亦然； 计算BFC的高度时，其中的浮动元素也参与计算。 如何创建BFC float的值不是none; position的值不是static或者relative； display的值是inline-block、table-cell、flex、table-caption或者inline-flex; overflow的值不是visible。 BFC的作用 利用BFC避免margin重叠 自适应两栏布局 清除浮动 参考链接： 什么是BFC？看这一篇就够了","link":"/2020/02/26/bfc/"},{"title":"从一道题里说闭包","text":"先看例子 实现一个具有累加器作用的函数，即每次调用函数，调用次数可以累加。 这是一个经典的可以使用闭包实现的函数，正确的写法应该类似于： 函数一 1234567var counter = (function outer() { let count = 0; return function inner() { count ++; return count; }}()) 后来我凭借记忆写了一个错误的函数： 函数二 1234567var counter = function outer() { let count = 0; return (function inner() { count ++; return count; }())} 这两个函数非常相似，一个是外层是自执行函数，一个是内部是自执行函数，并且都用到了闭包，为什么后者却是错误的？ 且看分析： 在第一个函数中，如果我们把外层自执行函数去掉，换成普通函数，那么应该是 1234567var counter = function() { let count = 0; return function() { count ++; return count; }} 可见counter自身是一个函数，执行结果返回了一个函数，即： 1234var outer = counter();var result = outer();// var result = counter()(); 函数一把内层定义的函数inner返回到了外层，并且在外层执行了内层的定义函数。而内层函数inner引用了外层函数outer的变量count，所以当内层函数没有被释放的时候，外层函数也不会被释放，因此外层函数outer内的变量count自然不会被释放。 所以函数一每次执行，计数器count可以累计，不会在每次执行函数时重新定义。 而函数二在函数内部定义了一个函数inner，并且将inner函数执行结果返回到了外层。即，函数inner在outer的内部定义，也在outer的内部执行。所以当函数outer执行的时候，事实上inner已经执行完毕了。因此，即使同样引用了外层变量count，这里却没有发生引用无法释放的问题。 所以函数二每次执行完毕，销毁变量count，每次执行时重新定义，因此无法实现count累计的功能。","link":"/2020/03/06/closure/"},{"title":"手写拷贝函数","text":"拷贝的核心思想，是将目标对象（包括数组）里的每一对键值对，复制到新对象中，最终返回新对象。从而完成了对象的拷贝功能。 拷贝分为深拷贝和浅拷贝两种方式，主要区别在于拷贝过程中，对于引用数据类型的处理。我们知道，如果将一个引用数据类型赋值给一个变量，该变量获取到的是一个引用地址，如果要完成深拷贝，则需要新开辟一个地址空间，用于存储引用地址对应的值。 浅拷贝只复制对象值，不考虑数据类型。 12345678910111213141516class ShallowCopy { constructor (target) { // 判断复制对象的数据类型，如果是基础类型，则直接赋值 if (typeof target !== 'object') return target; // 判断复制对象是数组类型还是普通对象类型 const copy = Array.isArray(target) ? [] : {}; // 遍历复制对象的键值对 for (const key in target) { // 思考这里为什么要判断hasOwnProperty if (target.hasOwnProperty(key)) { copy[key] = target[key]; } } return copy; }} 深拷贝在浅拷贝的基础上，判断所复制的值的类型，如果是引用类型，则新开辟一个地址空间用于存储。 12345678910111213141516171819class DeepCopy { constructor (target) { if (typeof target !== 'object') return target; const copy = Array.isArray(target) ? [] : {}; for (const key in target) { if (target.hasOwnProperty(key)) { const value = target[key]; // 如果是引用数据类型，则递归调用深拷贝 if (value &amp;&amp; typeof value === 'object') { copy[key] = new DeepCopy(value) } else { copy[key] = target[key] } } } return copy }}","link":"/2021/01/25/copy/"},{"title":"手写柯里化函数","text":"柯里化函数可以把接收多个参数的函数转换成一个接收单一参数的函数，可以只传递一部分参数来调用它，让它返回一个函数来处理剩余的参数，直到传递所有参数为止。 固定参数长度123456789101112131415function curry(fn) { // 记录原函数的参数数量 const argsLen = fn.length; return function core() { const innerArgs = [].slice.call(arguments) if (innerArgs.length &lt; argsLen) { return function () { const _args = [].slice.call(arguments) return core.apply(null, innerArgs.concat(_args)) } } return fn.apply(null, innerArgs) }} 简洁版 1234const curry = (fn, args1 = []) =&gt; (...args2) =&gt; { const args = [...arg1, ...arg2] return args.length === fn.length ? fn(...args) : curry(fn, args)} 不固定参数长度1234567891011121314151617function curry(fn) { // 保存预置参数 const presetArgs = [].slice.call(arguments, 1) function curried() { const restArgs = [].slice.call(arguments) const allArgs = [...presetArgs, ...restArgs] return curry.call(null, fn, ...args) } // 重写toString curried.toString = function() { return fn.apply(null, presetArgs) } return curried;}","link":"/2021/02/10/curry/"},{"title":"Decrator","text":"Decrator Decrator即修饰器，是ES7的一个提案，本质上是一个函数，用来修饰类的行为。 基础1.类修饰器（只有一个参数） target -&gt; 指向类，如果类型是function，则指向Myfunction.prototype 12345678910const animalDecrator = (target) =&gt; { target.isAnimal = true; target.protoType.nickName = 'nimo'};@animalDecratorclass Cat {}console.log(Cat.isAnimal); // trueconsole.log((new Cat()).nickName); // 'nimo' 2.方法修饰器（接受三个参数） target -&gt; 方法所在的类 key -&gt; 方法名称 descriptor -&gt; 描述对象 123456789101112131415const log = (target, key, descriptor) =&gt; { const originFunc = descriptor.value; descriptor.value = (...args) =&gt; { console.log(`${key}:`, args); originFunc.apply(this, args); } return descriptor;};class Utils { @log static setParam (params) {}}Utils.setParams({name: 'lvming'}); // 'setParam: {name: &quot;lvming&quot;}' 修饰器可以传参数，如果需要传参的话，内部需要返回一个方法 123456789101112131415161718const log = (name) =&gt; { return (target, key, descriptor) =&gt; { const originFunc = descriptor.value; descriptor.value = (...args) =&gt; { console.log(`${key} ${name}:`, args); originFunc.apply(this, args); } return descriptor; }}class Utils { @log('hello') static setParam (param) {}}Utils.setParam({name: 'lvming'})// 'setParam hello: {name: &quot;lvming&quot;}' 注意 修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升 原理Decrator本质上是利用了ES5的Object.defineProperty特性，通过劫持手段，给方法或属性注入了相关的特性。 执行以下代码 123456789101112131415function readOnly(target, key, descriptor) { descriptor.writable = false; return descriptor;}class Dog { @readOnly bark () { return 'wang wang!!' }}let dog = new Dog();dog.bark = 'miao miao!!';// Cannot assign to read only property 'bark' of [object Object] 本质上是做了如下操作 12345678910class Dog { bark () { return 'wang wang!!' }}Object.defineProperty(Dog.prototype, 'bark', { writable: false}) 应用事件统计 假如我们需要统计页面中每个按钮的点击次数 12345678910111213141516const log = (btn) =&gt; { return (target, key, descriptor) =&gt; { const originFunc = descriptor.value; descriptor.value = (...args) =&gt; { console.log(`按钮${btn}触发了一次`); originFunc.apply(this, args); } return descriptor; }}class MyClass { @log('confirm') handleConfirm () {}}","link":"/2020/04/15/decrator/"},{"title":"Diff算法","text":"Diff算法是Vue的核心之一，通过比较Virtual DOM的方式，只更新新旧节点真正产生差异的部分，而非重新渲染整个DOM结构，从而提升框架性能。 Diff 作用渲染真实DOM需要很大的开销，比如我们修改了某个数据，假如将修改结果直接渲染到真实DOM上，会引起整个DOM结构的重绘和重排序。因此我们需要一种算法，帮助我们实现尽可能只更新真正需要修改的部分，而不是更新整颗DOM树。Diff算法能够实现这样的需求。 Diff 做法我们先根据真实DOM结构生成一颗Virtual DOM，当Virtual DOM某个节点的数据发生变化后，会生成一个新的Vnode，然后将Vnode和oldVnode作对比。 **Vue只会比较Vnode节点，而不是比较DOM**。 因为Vnode是JS对象，不受平台限制，所以以它作为比较基础，代码逻辑后期不需要改动，拿到比较结果后，根据不同平台调用相应的方法进行处理就好了。 Diff 逻辑 Diff比较的内核是节点复用，所以Diff比较就是为了在新旧节点中找到相同节点。 Diff算法只会比较拥有相同父节点的的同级节点，不会进行跨级比较，也不是无限制的递归查找。 什么是拥有相同父节点的同级节点？比如下图出现的 四次比较（从 first 到 fouth），他们的共同特点都是有相同的父节点 比如 蓝色方的比较，新旧子节点的父节点是相同节点1 比如 红色方的比较，新旧子节点的父节点都是2 所以他们才有比较的机会 而下图中，只有两次比较，就是因为在 蓝色方 比较中，并没有相同节点，所以不会再进行下级子节点比较 什么是节点复用？ 节点复用是指新旧节点中，没有产生差异，不需要进行新建或则删除等操作的节点。 节点复用需要满足以下条件： 在旧节点中没有产生差异； 拥有相同的父级节点 属于同一级节点 如下图，在新旧节点树中，节点6拥有相同的父节点8，并且新旧节点中，节点6同属于第三级节点，因此可以满足节点复用的条件。 比如下图，在新旧节点树中，拥有相同的子节点6，但由于前后所属的层级不一样，因此不会产生节点复用。 再如下图，在新旧节点树中，拥有相同的子节点6，并且属于同一层级，但是前后的父节点不一样，也不满足节点复用的条件。 Diff流程图当数据发生改变时，set方法会调用Dep.notify通知所有订阅者Watcher，订阅者就会调用patch给真实的DOM打补丁，更新相应的视图。 具体分析 patch 1234567891011121314151617function patch (oldVnode, vnode) { // some code if (sameVnode(oldVnode, vnode)) { patchVnode(oldVnode, vnode) } else { const oEl = oldVnode.el // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl) // 父元素 createEle(vnode) // 根据Vnode生成新元素 if (parentEle !== null) { api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)) // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el) // 移除以前的旧元素节点 oldVnode = null } } // some code return vnode} 12345678910function sameVnode (a, b) { return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 )} 判断两节点是否值得比较，值得比较则执行patchVnode 不值得比较则用Vnode替换oldVnode patchVnode 1234567891011121314151617patchVnode (oldVnode, vnode) { const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) { api.setTextContent(el, vnode.text) }else { updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) { updateChildren(el, oldCh, ch) }else if (ch){ createEle(vnode) //create el's children dom }else if (oldCh){ api.removeChildren(el) } }} 这个函数做了一下事情： 找到对应的真实dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 updateChildren 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869updateChildren (parentElm, oldCh, newCh) { let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) { if (oldStartVnode == null) { // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] }else if (oldEndVnode == null) { oldEndVnode = oldCh[--oldEndIdx] }else if (newStartVnode == null) { newStartVnode = newCh[++newStartIdx] }else if (newEndVnode == null) { newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newStartVnode)) { patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] }else if (sameVnode(oldEndVnode, newEndVnode)) { patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldStartVnode, newEndVnode)) { patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] }else if (sameVnode(oldEndVnode, newStartVnode)) { patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] }else { // 使用key时的比较 if (oldKeyToIdx === undefined) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 } idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] } else { elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) { api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) }else { patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) } newStartVnode = newCh[++newStartIdx] } } } if (oldStartIdx &gt; oldEndIdx) { before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) }else if (newStartIdx &gt; newEndIdx) { removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) }} 这个函数做了一下事情： 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的2个变量相互比较，一共有4种比较方式。如果4种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 参考链接： 【Vue原理】Diff - 白话版 详解vue的diff算法","link":"/2020/03/01/diff/"},{"title":"事件循环","text":"JS 为什么是单线程？ JS最初设计是应用在浏览器中运行，假如JS是多线程机制，则可能存在这样的情况： 1现有两个线程Process1和Process2，它们同时对同一个Dom节点进行操作，其中Process1删除该Dom节点，而Process2编辑该Dom节点。这是两个矛盾的命令，浏览器将无法运行。 因此，JS需要被设计成单线程。 JS 为什么需要异步？由于JS的单线程机制，决定了其运行顺序自上而下。如果不存在异步，则后边的程序必须等待前边的程序执行完成才可以进行开始运行。如果前边的程序程序运行时间过长，则导致线程阻塞，浏览器可能处在长时间无响应的状态。因此需要异步执行。 JS 如何实现异步？JS是通过事件循环(event loop)来实现异步的，event loop 的机制代表了JS的执行机制。 举个例子： 12345console.log(1);setTimeout(() =&gt; { console.log(2);}, 0);console.log(3); 以上程序的运行结果是：1，3，2。 也就是说，setTimeout 里的函数并没有立即执行，而是延迟了一段时间，在满足一定的条件之后才会执行。这样的代码称为异步代码，反之称为同步代码。 在此可以简单概括JS的运行机制如下（event loop(1)）： 首先判断JS是同步还是异步， 同步任务立即进入主线程，异步任务则进入到event table 异步任务在event table中注册函数，当满足触发条件之后，该任务被推入到event queue中 同步任务会在主线程上一直执行，直到主线程处于空闲状态，此时，主线程会到event quene中查看是否有可执行的任务，如有，则将该任务推入主线程中继续执行 如此反复，称为事件循环 在此对以上例子进行解析： 123456789console.log(1); //任务1，同步任务，进入到主线程里setTimeout(() =&gt; { //任务2，异步任务，进入到event table注册函数，0秒之后被推入event queue中 console.log(2);}, 0);console.log(3); //任务3，同步程序，进入到主线程里主线程在完成了任务1、任务3后，检查event queue是否存在可执行函数，执行setTimeout里的函数。因此最终的输出结果是1-3-2。 在此需要注意的是，异步任务的执行需要两个条件： 满足触发条件 主线程空闲 因此，将函数体setTimeout(() =&gt; fn(), 3000)解释为“定时器在 3 秒之后执行 fn”并不准确，准确的解释应该是： 13秒后，fn被推入到event queue，当主线程空闲时，fn从event quene推入到主线程中执行 正因如此，我们并不能完全依赖 setTimeout 作为一个定时器，对于setTimeout(() =&gt; fn(), 3000)，如果主线程需要运行 10 秒，则 fn 实际上是 13 秒后才开始运行。 再看一个例子： 12345678910setTimeout(() =&gt; console.log(1), 0);new Promise(resolve =&gt; { resolve(2); console.log(3);}).then((res) =&gt; { console.log(res);});console.log(4); 假如我们利用之前的知识去分析： 12345678910setTimeout(() =&gt; console.log(1), 0); //任务1，异步任务，进入event table注册，0秒后进入event queuenew Promise(resolve =&gt; { //任务2，同步任务，其中包含 resolve(2); console.log(3); //任务3，同步任务}).then((res) =&gt; { //任务4，异步任务，在event table注册后进入event queue，排在任务1之后 console.log(res);});console.log(4); //任务5，同步任务 根据此分析，最终的输出结果是：3-4-1-2 这是正确的输出结果吗？程序执行之后，得到的最终结果应该是：3-4-2-1 是否因为异步任务的执行顺序不是前后顺序而另有规定，导致输出结果与我们预知的不一样？ 事实上，单纯的按照异步和同步的划分方式，并不准确。 准确的划分方式是： macro-task(宏任务)：包括整体代码 script,setTimeout,setInterval micro-task(微任务)：Promise, process.nextTick 按照这样的分类方式，JS 的执行机制是（event loop(2)）： 执行一个宏任务，过程中如果遇到微任务，就将其放在微任务的【事件队列】里 当前宏任务执行完成后，会查看微任务的【事件队列】，并将其中的全部微任务执行完成 重复以上 2 步骤，结合 event loop(1)和 event loop(2),就可以得到更准确的 JS 执行机制。 此时我们再去分析刚刚出错的列子： 1234561.首先执行script下的宏任务，遇到setTimeout,将其放在宏任务的【队列】里2.遇到 new Promise直接执行，里边的同步任务cosnole.log(3)立即触发3.遇到 then 方法，是微任务，将其放在微任务的【队列】里4.遇到console.log(4)直接执行。5.当主线程完成cosnole.log(3)和console.log(4)后，会去检查微任务的【队列】,发现其中的任务 then,于是执行console.log(res),此处的res === 2;6.当微任务完成之后，会去检查宏任务【队列】，发现setTimeout,并执行","link":"/2020/02/24/event-loop/"},{"title":"flex布局","text":"Flex布局是什么？Flex是Flexible Box的缩写，意为弹性布局，用来为盒子模型提供最大的灵活性。 基本概念采用Flex布局的元素，称为Flex容器（flex container），简称“容器”。它的所有子元素称为容器成员（flex item），简称“项目”。 容器默认存在两根轴：水平得分主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据主轴的空间叫做main size，占据交叉轴的空间叫做cross size。 容器的属性以下6个属性设置在容器上。 123456* flex-direction* flex-wrap* flex-flow* justify-content* align-items* align-content flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box { flex-direction: row | row-reverse | column | column-reverse} 它可能有4个值: 1234* row（默认值）：主轴为水平方向，起点在左端。* row-reverse：主轴为水平方向，起点在右端。* column：主轴为垂直方向，起点在上沿。* column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条轴线上，flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box { flex-wrap: nowrap | wrap | wrap-reverse} 它可能有3个取值: 123* nowrap（默认值）：不换行。* wrap：换行，第一行在上方。* wrap-reverse：换行，第一行在下方。 flex-flowflex-flow属性是flex-direction和flex-wrap属性的简写形式，默认值为row nowrap。 123.box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;} justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 1234.box { justify-content: flex-start | flex-end | center | space-between | space-around;} 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右: 12345* flex-start（默认值）：左对齐。* flex-end：右对齐。* center：居中。* space-between：两端对齐，项目之间的间隔都相等。* space-around：每个项目的两侧间隔相等。所以项目之间的间隔比项目与边框的间隔大一倍。 tips: space-around 属性不可实现项目等分排列 align-items属性align-items属性定义项目在交叉轴上如何对齐。 123.box { align-items: flex-start | flex-end | center | baseline | stretch;} 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 12345* flex-start：交叉轴的起点对齐。* flex-end：交叉轴的终点对齐。* center：交叉轴的中心对齐。* baseline：项目第一行文字的基线对齐。* stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器高度。 align-content属性align-content属性定义了多根轴线的对齐方式。如果只有一根轴线，该属性不起作用。 123.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch;} 该属性可能取6个值： 123456* flex-start：与交叉轴的起点对齐。* flex-end：与交叉轴的终点对齐。* center：与交叉轴的中点对齐。* space-between：与交叉轴的两端对齐，轴线之间的间隔平均分布。* space-around：每根轴线两侧分间隔都相等。所以轴线之间的间隔比轴线与边框的间隔大一倍。* stretch（默认值）：轴线占满整个交叉轴。 项目属性以下6个属性设置在项目上： 123456* order* flex-grow* flex-shrink* flex-basis* flex* align-self order属性order属性定义项目分排列顺序。数值越小。排列越靠前，默认为0. 123.item { order: &lt;integer&gt;;} flex-grow属性flex-grow属性定义项目的放大比例，默认是0，即如果存在剩余空间，也不放大。 123.item { flex-grow: &lt;number&gt;; /* default 0 */} 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认是1，即如果空间不足，该项目将缩小。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值是auto，即项目的本来大小。 123.item { flex-basis: &lt;length&gt; | auto; /* default auto */} 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间 flex属性flex属性是flex-grow、flex-shrink和flex-basic简写，默认为0 1 auto。后两个属性可选。 123.item { flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-self属性align-self属性允许单个项目有其他项目不一样的对齐方式，可覆盖align-items属性。默认值是auto，表示继承了父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item { align-self: auto | flex-start | flex-end | center | baseline | stretch;} 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","link":"/2020/02/27/flex/"},{"title":"函数声明与函数表达式的区别","text":"先看一个例子 12345678910111213function fn(flag) { if (flag) { function getValue() { return &quot;a&quot;; } } else { function getValue() { return &quot;b&quot;; } } return getValue();} 对于函数声明，解析器会率先读取并且让其在执行任何代码前可用，意思就是别的代码还没有运行的时候，被声明的函数已经被读取了，效果相当于 123456789101112function fn(flag) { function getValue() { return &quot;a&quot;; } function getValue() { return &quot;b&quot;; } if (flag) { } else { } return getValue();} 如此，后边声明的函数会覆盖前边声明的函数。 而对于函数表达式，解析器只有执行到它所在的位置时才会真正地去解释和执行，因此可用函数表达式来修复这个问题。 12345678910111213function fn(flag) { if (flag) { var getValue = function() { return &quot;a&quot;; }; } else { var getValue = function() { return &quot;b&quot;; }; } return getValue();}","link":"/2020/02/24/function-declaration/"},{"title":"关于nginx配置gzip这件事","text":"最近在研究web网页优化相关的知识，其中有一项是关于网络请求方面的优化，其中就有提到开启gzip。我突然想到，我的服务器nginx有没有开启gzip呢？（因为服务器上的nginx是很久之前配置的了，我甚至忘了当初是自己配置的还是请同事帮忙的，所以对gzip这个事不是很确定。）于是马上登录远程服务器，查看nginx配置。果然不出所料，没有！ 那还有什么好说的呢，整起来吧！ 不过在添加配置之前，先抓一下当前的站点请求，方便与配置后的效果做对比。 随便抓一个main.js看看 Response Headers: 1234567Accept-Ranges: bytesConnection: keep-aliveContent-Length: 5944Content-Type: application/javascriptServer: nginx/1.16.1...... 可以看到当前的Response Headers并没有gzip相关字段。 当前main.js的size是6.2kb，加载时间是184ms。 再看看目前网页加载的整体情况： 41 requests 24.2 MB transferred 24.6 MB resources Finish: 2.8 min DOMContentLoaded: 3.30 s Load: 2.8 min 以上就是开启gzip前的大致信息。接下来开始进入gzip配置。 在nginx.conf文件中添加 1234567gzip on;gzip_buffers 32 4K;gzip_comp_level 6;gzip_min_length 100;gzip_types application/javascript text/css text/xml;gzip_disable &quot;MSIE [1-6]\\.&quot;; #配置禁用gzip条件，支持正则。此处表示ie6及以下不启用gzip（因为ie低版本不支持）gzip_vary on; 说说各配置项的含义 123456789gzip on|off; #是否开启gzipgzip_buffers 32 4K| 16 8K #缓冲(压缩在内存中缓冲几块? 每块多大?)gzip_comp_level [1-9] #推荐6 压缩级别(级别越高,压的越小,越浪费CPU计算资源)gzip_disable #正则匹配UA 什么样的Uri不进行gzipgzip_min_length 200 # 开始压缩的最小长度(再小就不要压缩了,意义不在)gzip_http_version 1.0|1.1 # 开始压缩的http协议版本(可以不设置,目前几乎全是1.1协议)gzip_proxied # 设置请求者代理服务器,该如何缓存内容gzip_types text/plain application/xml # 对哪些类型的文件用压缩 如txt,xml,html ,cssgzip_vary on|off # 是否传输gzip压缩标志 然后重启nginx: service nginx restart。 这样就已经完成了gzip配置了。此时我们再来看看同一个网页的加载情况。 还是main.js。 Response Headers: 12345678Connection: keep-aliveContent-Encoding: gzipContent-Type: application/javascriptServer: nginx/1.16.1Transfer-Encoding: chunkedVary: Accept-Encoding...... 可见，相比于之前的Response Headers，开启了gzip功能后的Response Headers新增了Content-Encoding: gzip、Transfer-Encoding: chunked、Vary: Accept-Encoding这几个关键信息。 而当前main.js的size是2kb，加载时间是96ms。 再看看目前网页加载的整体情况： 36 requests 23.5 MB transferred 24.2 MB resources Finish: 2.8 min DOMContentLoaded: 1.70 s Load: 2.8 min 可以看出，我们的gzip配置已经生效了，并且单个文件的优化效果也很明显了。 可是除了main.js和DOMContentLoaded指标，为什么Finish和Load时间几乎没有变化呢？ 原来是因为我的博客网页加载了很多照片，并且照片资源都比较大；再看看gzip配置gzip_types application/javascript text/css text/xml;。可以看出来，我们的gzip_types没有配置image类型，也就是对于图片类型的文件，并没有开启gzip压缩。而图片资源恰好占据了这个网页的主要加载时间，所以Finish和Load时间几乎没有变化。 问题来了，为什么gzip_types没有配置image类型呢？ 这涉及到一个知识点，什么样的资源不适合开启gzip压缩？ 答案是二进制资源。 二进制资源比如图片、mp3，因为这些资源本身已经采用了二进制格式，所以压缩空间是非常有限的，比如100-&gt;80字节，而压缩也是耗费CPU资源的。相比于有限压缩，CPU资源显得更为重要，所以一般对于二进制资源，通常不会开启gzip压缩。 以上。","link":"/2021/03/25/gzip/"},{"title":"Hello Hexo","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/02/23/hello-hexo/"},{"title":"如何使用Hexo和Github Pages搭建个人博客","text":"什么是 Hexo? Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 如何安装? 安装前提: 安装Node.js 安装Git安装教程 开始安装： 全局安装 Hexo $ npm install -g hexo-cli 使用 Hexo工具初始化一个项目 hexo init blog 进入到初始化后的项目，并下载安装包 cd blog &amp; npm install 使用 Hexo 启动项目 hexo server tips: hexo 安装完成后，最好使用 hexo -v命令检查是否安装成功，题主在使用npm安装时，可能由于个人电脑环境的关系，导致hexo没有写入全局环境里，所以一直无法使用hexo命令，最后使用yarn安装解决了该问题，读者也可以从环境变量的角度去解决问题。 hexo 安装成功后，可能项目会因为缺少模版文件导致在启动项目后页面无法显示的问题，不要轻易放弃，继续往下看即可。 安装主题挑选你喜欢的主题风格，在项目根目录下进行安装 如： 1git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 安装完成后，项目根目录中会生成themes文件夹，用于存放主题，然后通过根目录下的_config.yml文件进行主题配置 1theme: your theme 将your theme改成你的主题名字，主题名字应该与themes目录下的文件夹名字保持一致。 主题即模版，因此安装完成主题之后，一般能够解决缺少模板而导致的问题，此时应该可以顺利启动项目了。 借助 GitHub Pages 部署自己的博客项目 新建 GitHub 仓库 tips: 如何新建 github 仓库不在本教程的教学之内。 新建仓库时，请确保仓库权限是public而非private，题主开始在新建仓库的时候选择了private，导致后续的Github Pages配置一直遇到问题，项目部署后却无法打开网址 保存新生成的仓库地址 打开上文提到的_config.yml进行配置 1234deploy: type: git repo: git@github.com:yourgithub.github.io.git branch: master tips: 找过deploy关键字开始配置； repo 后配置的是新建仓库时生成的仓库地址； 所有冒号之后都有一个空格。 安装hexo-deployer-git插件 1npm install hexo-deployer-git --save 安装该插件后，可以使用以下命令： hexo clean hexo g hexo d 其中： hexo clean 用于清除上次打包后的模板 hexo g 用于打包模板 hexo d 用于部署项目 项目部署地址即为我们在上文中的deploy配置的地址 打开 github 项目地址，即可访问在线博客 tips: 部署项目后，线上访问内容可能存在十分轴左右的延迟，并非及时更新。 参考链接： Hexo 使用 Github Pages 和 Hexo 搭建自己的独立博客【超级详细的小白教程】 轻松搞定 GitHub Pages 超详细Hexo+Github Page搭建技术博客教程","link":"/2020/02/24/hexo/"},{"title":"大话队头阻塞","text":"曾经对队头阻塞这个概念很迷糊，在看http2.0相关的文章时，有时候会提到“http2.0解决了http1.x时代的队头阻塞问题”，有时候又会看到“http2.0依然存在队头阻塞问题，所以http3.0改用了UDP协议”。这就很迷惑了，这个队头阻塞到底有没有被解决呢？让我来说道说道。 假设麦当劳店是服务器，麦当劳店外是浏览器，每个排队的人是一个请求 话说我家楼下有一家麦当劳，每天都是人来人往，生意火爆。最开始的时候，这家麦当劳店里只有一个服务台。 这里对应的是http1.0时代，浏览器和服务器只有一条TCP连接 想要买麦当劳的朋友们，只能排成一列长队按序走到店里。 这里对应的是浏览器按序发起请求 并且这家店有一个规定，只有服务完前一个顾客，才开始服务后一个顾客。 可是经常遇到的问题是，当前顾客订单太多了，一个人买了几十份套餐，工作人员需要忙活好久才能满足这个顾客的需求。由于店家规定服务完当前顾客才能接纳下一个顾客，所以导致很多人根本进不到店里，店外排队的人太多，都快造成交通堵塞了！ 这里对应的就是http1.0时代的队头阻塞问题，指的是服务器响应单个请求耗时过长，导致浏览器请求队列阻塞，甚至造成浏览器请求瘫痪 后来麦当劳想，这样不行啊，有没有办法提高效率呢？一个店员就说了，“我们能不能多请一些人，然后可以多开几个服务台，这样顾客就可以多排成几个队列了”。这个主意很好，很快就被老板采纳了。 这里对应的是http1.1时代的pipelining管道技术，实现一次性发起多个请求，即多个TCP连接 虽然多开了几个服务台，但由于店内的结构问题，顾客需要按序离开，即服务台1的顾客离开了，服务台2的顾客才能出去，依次，服务台3顾客，服务台4顾客…… 这里对应的是TCP的有序连接，TCP遵循FIFO，即先进先出的原则 经营一段时间后，发现还是存在问题。虽说多开几条队列，可以同时提高服务效率，也减缓了店外的排队压力，但由于店内的顾客是按序离开的，所以假如服务台1的顾客还没走，其他服务台即使已经结束了，那些顾客也走不了啊！店外的排队压力减缓了，店内的排队压力却增加了。 这里对应的是http1.1时代的pipelining所带来的问题，本质上依然没有解决队头阻塞，只不过是把浏览器的队列压力转化成了服务器内部的队列压力 这下老板不乐意了，“劳资花了那么钱多请了那么些员工，你们就给我整这个？”于是又有一个店员来出谋划策了，“现在出餐那么慢，是因为我们需要把顾客的套餐都凑齐了才给到顾客，而且我们怕把顾客的订单搞混了，所以一个人只负责准备一个套餐，这样就很慢了。假如我们可以把顾客的套餐拆成许多小分，比如可乐、薯条、鸡块、汉堡…然后所有店员都可以协同来准备同一个套餐，这样速度就会快很多！” 这里对应的是http2.0的二进制分帧 不愧是老板的小心肝，这样的确很大程度的提高了服务效率，而且也不需要多开几个服务台了（因为多服务台并没有从本质上解决问题）。甚至连顾客都不需要排队了，他们可以分为很多趟跑到服务台去，“我的1001有一个可乐”，“我的1002有一个薯条”，“我的1003有一个汉堡”，“我的1001还有一个鸡块”…… 麦当劳的店员们同时响应这些颗粒化的需求，并且由于每个人都报了自己的单号，所以即便是颗粒化的去准备套餐，结果也不会出错。每个套餐单品准备好了之后，都会送到缓冲区，让缓冲区的工作人员负责根据编号来将这些单品组装成一个套餐，完后再派发给顾客。 这里对应的是http2.0二进制分帧的ID信息，服务器根据ID将所有的分帧包组装成一个完整的响应信息 这下效率快多了，顾客也不需要在店外排长队了，不会阻塞外边的交通问题了。 这里对应的是http2.0解决了http队头阻塞的问题 还记得上边提到的“顾客需要按序离开”的问题吗？虽说现在顾客是可以一窝蜂的跑到店里了，但如果1001的套餐还没凑齐，即便1002、1003的套餐准备好了，他们也走不了啊。所以一旦前一个人的套餐没准备好，比如套餐里可乐弄洒了，店员就会优先再给他准备一份可乐，直到他的套餐已凑齐。一旦发生这种情况，简直比没改良之前的模式更糟糕！因为现在顾客的进店量变大了，一旦前一个人出不去，后边的人简直就乱了套。 这里对应的是如果http2.0产生丢包问题，等待重传而导致的队头阻塞，可能比http1.x时代更加严重 所以如果不修改店里的结构限制，不解决先进先出的问题，采用套餐分包的模式，也无法彻底去解决顾客拥挤的问题。 这里对应的是TCP队头阻塞，不抛弃TCP协议，即便解决了http队头阻塞，也无法从解决TCP队头阻塞","link":"/2021/02/17/hol-blocking/"},{"title":"HTTP那些事","text":"http的基本优化影响一个http网络请求的因素主要有两个：带宽和延迟。 带宽：拨号上网的阶段，带宽可能会是一个严重影响请求的问题，但是现代网络基础建设的优化使得带宽不再成为影响网速的问题； 延迟： 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。对于同一个域名，PC浏览器一般可以同时支持4～6个连接，手机浏览器则更少，超过浏览器最大连接数限制时，后续请求就会被阻塞，这也是为什么当请求量大的时候，可以将资源部署多台服务器或则使用CDN进行优化的原因。 DNS查询（DNS Lookup）：浏览器需要知道目标服务器的IP地址才能建立连接。**将域名解析成IP地址的这个系统就是DNS**。如果每次连接都经过DNS解析是一个很耗时的过程，通常可以利用DNS缓存来减少解析所消耗的时间。 建立连接（Initial Connection）：**HTTP是基于TCP协议的**，浏览器最快也要在完成三次握手后才能捎带HTTP请求报文，实现建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响明显，慢启动则对大文件类型的请求影响较大。 HTTP1.0和HTTP1.1的一些区别 缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since、Expires来作为缓存的判断标准，HTTP1.1则引入了更多的缓存控制策略，比如Entity Tag、If-Unmodified-Since、If-Match、 If-None-Match等更多的请求头来控制缓存策略； 带宽优化和网络连接的使用：HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 错误通知的管理：在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。 Host头处理：在HTTP1.0中认为每台服务器都绑定唯一的IP地址，因此请求消息中的URL并没有传递主机名（hostname），随着虚拟主机技术的发展，一台物理服务器可以存在多个虚拟主机，并且它们共享一个IP地址。HTTP1.1请求消息和响应消息都支持Host头域，且请求消息中如果没有Host头域会报告错误（400 Bad Request）。 长连接：HTTP1.1支持长连接（PersistenConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立连接和关闭连接的消耗和延迟，**在HTTP1.1中默认开启Connection：keep-alive**，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 HTTPS和HTTP的一些区别 HTTPS协议需要到CA申请证书； HTTP协议运行在TCP之上，所有传输的内容都是明文的，HTTPS运行在SSL/TSL之上，SSL/TSL运行在TCP之上，所有的传输内容都经过加密； HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80端口，后者是443端口； HTTPS可以有效解决劫持问题。 什么是SPDYSPDY是Google在2012年提出的方案，优化HTTP1.X的请求延迟，解决了HTTP1.X的安全性问题，具体如下： 降低延迟：SPDY采用了多路复用的方式，通过多个请求stream共享一个TCP连接，解决了HOL blocking的问题，降低了延迟，同时提高了带宽的利用率； 请求优先：**SPDY允许给每一个请求设置优先级**，这样重要的请求就会优先得到响应； header压缩： 选择合适的压缩算法可以减少包的大小和数量； 基于HTTPS的加密协议传输，提高数据传输的可靠性； 服务端推送（server push）：当客户端像服务端请求一个文件的时候，服务端可以将客户端后续可能需要的文件也推送给它，当客户端再次尝试获取该文件的时候，就可以直接从缓存中获取，不用再发请求。 SPDTY位于HTTP之下，TCP和SSL之上，这样可以方便兼容老版本的的HTTP协议，并且可以使用已有的SSL 功能。 TCP ——&gt;SSL——&gt;SPDY——&gt;HTTP HTTP2.0HTTP2.0可以说是SPDY的升级版（原本基于SPDY）设计，所以包含以上提到的SPDY优点：**降低延迟、请求优先、header压缩、多路复用、服务端推送**等，但是和SPDY依然存在区别： HTTP2.0支持明文传输，而SPDY强制使用HTTPS加密传输 HTTP2.0消息头的压缩算法采用的是HPACK，而SPDY采用的是DEFLATE","link":"/2020/02/24/http/"},{"title":"import和require的区别","text":"import和require都是用于模块化引入，是模块化编程的功能。 遵循规则 require是AMD规范的引入方式 import是es6的一个语法标准 调用时间 require是运行时调用，所以require理论上可以运用在代码的任何地方 import是编译时调用，一般放在文件开头（import命令具有提升效果，会提升到整个模块的头部，所以并不是必须写在开头） 本质 require是赋值过程，其实require的结果就是对象、数字、字符串、函数等，再把require的结果赋值给某个变量 import是解构的过程，对于没有实现import的引擎，使用babel转译后，import的语法会转码成require 导出 require/exports: 遵循CommonJS/AMD的规则，只能在运行时确定模块的依赖关系以及输入/输出的变量，无法进行静态化处理。 node的module遵循CommonJS规范 requireJS遵循AMD规范 seaJS遵循CMD规范 用法如下： 123const fs = require('fs');exports.fs = fs;module.exports = fs; import/export: 遵循es6规范，支持编译时静态分析，便于引入宏和类型校验，动态绑定。 用法如下： 1234567891011import fs from 'fs';import {default as fs} from 'fs';import * as fs from 'fs';import {readFile} from 'fs';import {readFile as read} from 'fs';import fs, {readFile} from 'fs';export default fs;export const fs;export function readFile;export {readFile, read}; 总结 通过require引入基础数据类型时，属于复制该变量； 通过require引入复杂数据类型时，数据浅拷贝该对象； 出现模块之间的循环引用时，会输出已经执行的模块，而未执行的模块不输出； CommonJS模块默认export的是一个对象，即使导出的是基础数据类型。","link":"/2020/07/23/import-require/"},{"title":"继承的实现方式","text":"函数对象的继承写在前边，先创建一个父类，用于后边的继承。代码如下： 12345678910111213// 定义一个动物类function Animal(name) { //属性 this.name = name || &quot;Animal&quot;; //实例方法 this.sleep = function() { console.log(`${this.name} is sleeping`); };}//原型方法Animal.prototype.eat = function(food) { console.log(`${this.name} is eating ${food}`);}; 原型链继承核心：将父类的实例作为子类的原型 12345678function Cat() {}Cat.prototype = new Animal(&quot;cat&quot;);var cat = new Cat();console.log(cat.name); // 'cat';console.log(cat.sleep); // 'cat is sleeping'console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 非常纯粹的继承关系，实例是子类的的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 因为重定向了子类的原型指向，所以要为子类新增属性和方法，必须在new Animal()这样的语句后执行，不能放在构造器里 因为只能指向一个原型，所以无法实现更多的继承 来自原型对象的所有属性都被所有实例继承 创建子类实例时，无法向父类构造器传参 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类 12345678910function Cat(name) { Animal.call(this); this.name = name || &quot;Tom&quot;;}var cat = new Cat(&quot;cat&quot;);console.log(cat.name); //'cat'console.log(cat.sleep()); //'cat is sleeping'console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); //true 特点： 解决了 1 中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承(可以 call 多个父类对象) 缺点： 实例并非父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性和方法 无法实现函数的复用，每个子类都有父类的实例函数的副本，影响性能 实例继承核心：为父类添加新特性，作为子类的实例返回 12345function Cat(name) { var instance = new Animal(); instance.name = name || &quot;Tom&quot;; return instance;} 特点： 不限调用的方式，不管是new Cat()还是Cat()，返回的对象都具有相同的效果 缺点： 实例时父类的实例，不是子类的实例 不支持多继承 拷贝继承核心：遍历父类的原型属性，在子类的原型上添加父类原型的副本 1234567891011function Cat(name) { var animal = new Animal(); for (var p in animal) { Cat.prototype[p] = animal[p]; } Cat.prototype.name = name || &quot;Tom&quot;;}var cat = new Cat();console.log(cat instanceof Animal); //falseconsole.log(cat instanceof Cat); //true 特点： 可以实现多继承 缺点： 效率较低，内存占用高(因为要拷贝父类的属性) 无法获取父类不可枚举的方法(因为不可枚举的方法，无法在for in遍历中访问到) 组合继承核心：通过调用父类的构造，继承了父类的属性并保留传参，然后通过将父类实例作为子类原型，实现函数的复用 12345678910function Cat(name) { Animal.call(this); this.name = name || &quot;Tom&quot;;}Cat.prototype = new Animal();Cat.prototype.constructor = Cat;var cat = new Cat();console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 特点： 弥补了方式 2 中的缺陷，可以继承实例属性方法，也可以继承原型属性和方法 既是子类的实例，也是父类的实例 不存在引用属性的共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例(子类实例将子类原型上的那份给遮蔽了) 寄生继承核心：通过寄生方式，砍掉了父类的实例属性，在调用两次父类的构造的时候，就不会初始化两次实例属性和方法，避免了组合继承的缺点 1234567891011121314function Cat(name){ Animal.call(this); this.name = name || 'Tom'；}(function(){ var Super = function(){}; Super.prototype = Animal.prototype; Cat.prototype = new Super()})();Cat.prototype.constructor = Cat;var cat = new Cat();console.log(cat instanceof Animal); //trueconsole.log(cat instanceof Cat); //true 普通对象的继承Object()方法核心：将子对象的 prototype 属性指向父对象，从而将子对象和父对象连接起来 1234567function Object(o) { function F() {} F.prototype = o; return new F();}var Child = Object(Parent); 浅拷贝核心：将父对象的所有属性拷贝给子对象 123456789function extendCopy(p) { var c = {}; for (var i in p) { c[i] = p[i]; } return c;}var Child = extendCopy(Parent); 缺点：如果父对象的属性类型是数组或对象，那么实际上，子对象获得的只是一个内存地址，当子对象对该属性进行修改，也会影响到该属性在父对象上的值 深拷贝核心：递归调用‘浅拷贝’，将父对象的所有属性深度拷贝给子对象，而非指针的指向关系 1234567891011121314function deepCopy(p, c) { var c = c || {}; for (var i in p) { if (typeof p[i] === &quot;Object&quot;) { c[i] = p[i].constructor === Array ? [] : {}; deepCopy(p[i], c[i]); } else { c[i] = p[i]; } } return c;}var Child = deepCopy(Parent);","link":"/2020/02/24/inheritance-prototype/"},{"title":"Intersection Observer","text":"简介概念 IntersectionObserver接口提供一种异步观察目标元素与其祖先元素或顶级文档视图(viewport)交叉状态的方法。祖先元素与视图(viewport)被称为**根(root)**。 构造器IntersectionObserver() 创建一个新的IntersectionObserver对象，当其监听到目标元素的可见部分穿过一个或多个**阀(thresholds)**时，会执行指定的回调函数。 属性 threshold：决定什么时候触发回调函数。它是一个数组，每个成员都是一个门槛值，默认为[0]，即交叉比例（intersectionRatio）达到0时触发回调函数。用户可以自定义这个数组。比如，[0, 0.25, 0.5, 0.75, 1]就表示当目标元素 0%、25%、50%、75%、100% 可见时，会触发回调函数。 root：用于观察的根元素，默认是浏览器的视口，也可以指定具体元素，指定元素的时候用于观察的元素必须是指定元素的子元素。 rootMargin： 用来扩大或者缩小视窗的的大小，使用css的定义方法，10px 10px 30px 20px表示top、right、bottom 和 left的值。 方法 **disconnect()**：使IntersectionObserver对象停止监听工作。 **observe()**：使IntersectionObserver对象开始监听一个元素。 **takeRecords()**：返回所有观察目标的IntersectionObserverEntry对象数组。 **unobserve()**：使IntersectionObserver停止监听特定目标元素。 Intersection Observers示例IntersectionObserver懒加载（vue单文件组件简版）123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;img v-for=&quot;(image, i) in images&quot; :key=&quot;i&quot; src :data-img-url=&quot;image&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { images: [ 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247890587&amp;di=88d4066be3d57ac962a6bec37e265d37&amp;imgtype=0&amp;src=http%3A%2F%2F01.imgmini.eastday.com%2Fmobile%2F20170810%2F20170810151144_d41d8cd98f00b204e9800998ecf8427e_3.jpeg', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=4054762707,1853885380&amp;fm=26&amp;gp=0.jpg', 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247912077&amp;di=508a949e5e291875debf6ca844292cd4&amp;imgtype=0&amp;src=http%3A%2F%2F03imgmini.eastday.com%2Fmobile%2F20180827%2F20180827095359_6759372e9bd28026ee6f53b500fb4291_2.jpeg', ], }; }, mounted() { const images = document.querySelectorAll('img'); const observerLazyLoad = new IntersectionObserver((entries) =&gt; { entries.forEach((item) =&gt; { if (item.isIntersecting) { item.target.src = item.target.dataset.imgUrl; } }); }); images.forEach((image) =&gt; { observerLazyLoad.observe(image); }); },};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;img { display: block; height: 500px; margin: 30px;}&lt;/style&gt; IntersectionObserver吸顶（vue单文件组件简版）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;template&gt; &lt;div&gt; &lt;p class=&quot;fixed-top-helper&quot;&gt;&lt;/p&gt; &lt;p class=&quot;fixed-top-reference&quot;&gt;&lt;/p&gt; &lt;header&gt;头部&lt;/header&gt; &lt;main&gt; &lt;img v-for=&quot;(image, i) in images&quot; :key=&quot;i&quot; :src=&quot;image&quot; /&gt; &lt;/main&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { images: [ 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247890587&amp;di=88d4066be3d57ac962a6bec37e265d37&amp;imgtype=0&amp;src=http%3A%2F%2F01.imgmini.eastday.com%2Fmobile%2F20170810%2F20170810151144_d41d8cd98f00b204e9800998ecf8427e_3.jpeg', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=4054762707,1853885380&amp;fm=26&amp;gp=0.jpg', 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247912077&amp;di=508a949e5e291875debf6ca844292cd4&amp;imgtype=0&amp;src=http%3A%2F%2F03imgmini.eastday.com%2Fmobile%2F20180827%2F20180827095359_6759372e9bd28026ee6f53b500fb4291_2.jpeg', ], }; }, mounted() { const header = document.querySelector('header'); const fixedTopReference = document.querySelector('.fixed-top-reference'); fixedTopReference.style.top = `${header.offsetTop}px`; const observerFixedTop = new IntersectionObserver((entries) =&gt; { entries.forEach((item) =&gt; { if (item.boundingClientRect.top &lt; 0) { header.classList.add('fixed'); } else { header.classList.remove('fixed'); } }); }); observerFixedTop.observe(fixedTopReference); },};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.fixed-top-helper { height: 1px; background: #ccc;}header { background: #ccc; &amp;.fixed { position: fixed; top: 0; left: 0; width: 100%; }}main { img { display: block; height: 500px; margin: 30px; }}&lt;/style&gt; tips: * fixedTopReference是为了避免缓慢移动时add remove .fixed死循环，死循环的结果是抖动 * fixedTopHelper是为了避免被吸顶元素没有上一个sibling元素（也就是说被吸顶元素是最上层元素）时，避免缓缓移动时add remove .fixed死循环抖动，特殊引入的标签，需要设置1个px的height * fixedTopHelper需要与被吸顶元素保持样式一致，以确保好的用户体验。例如在本例中将其background设置为#ccc，很好的做到了隐藏 IntersectionObserver触底（vue单文件组件简版）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;div&gt; &lt;main&gt; &lt;img v-for=&quot;(image, i) in images&quot; :key=&quot;i&quot; src=&quot;image&quot; /&gt; &lt;/main&gt; &lt;footer&gt;底部&lt;/footer&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default { data() { return { images: [ 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247890587&amp;di=88d4066be3d57ac962a6bec37e265d37&amp;imgtype=0&amp;src=http%3A%2F%2F01.imgmini.eastday.com%2Fmobile%2F20170810%2F20170810151144_d41d8cd98f00b204e9800998ecf8427e_3.jpeg', 'https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=4054762707,1853885380&amp;fm=26&amp;gp=0.jpg', 'https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1574247912077&amp;di=508a949e5e291875debf6ca844292cd4&amp;imgtype=0&amp;src=http%3A%2F%2F03imgmini.eastday.com%2Fmobile%2F20180827%2F20180827095359_6759372e9bd28026ee6f53b500fb4291_2.jpeg', ], }; }, mounted() { const footer = document.querySelector('footer'); const observerTouchBottom = new IntersectionObserver((entries) =&gt; { entries.forEach((item) =&gt; { if (item.isIntersecting) { setTimeout(() =&gt; { console.log('滚动到了底部，可以发request请求数据了'); }, 2000); } }); }); observerTouchBottom.observe(footer); },};&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;main { img { display: block; height: 500px; margin: 30px; }}footer { background: #ccc;}&lt;/style&gt; 参考链接： Intersection Observer 90行代码，15个元素实现无限滚动 IntersectionObserver是什么？","link":"/2020/02/29/intersection-observer/"},{"title":"webpack资源压缩","text":"记录一些webpack打包资源压缩的方式。 压缩css–CssMinimizerWebpackPlugin 安装 1npm install css-minimizer-webpack-plugin --save-dev webpack.config.js 12345678910111213141516171819202122const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;);module.exports = { module: { rules: [ { test: /.s?css$/, use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;sass-loader&quot;], }, ], }, optimization: { minimizer: [ // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释 // `...`, new CssMinimizerPlugin(), ], }, plugins: [new MiniCssExtractPlugin()],}; 压缩js–TerserWebpackPlugin 安装 1npm install terser-webpack-plugin --save-dev webpack.config.js 12345678const TerserPlugin = require(&quot;terser-webpack-plugin&quot;);module.exports = { optimization: { minimize: true, minimizer: [new TerserPlugin()], },}; 压缩图片 使用loader的方式–image-webpack-loader 参数说明： - mozjpeg：JPEG 圖片優化器 - optipng：PNG 圖片優化器 - pngquant：PNG 圖片優化器 (推薦) - svgo：SVG 圖片優化器 - gifsicle：GIF 圖片優化器 - webp：WebP 圖片優化器 (預設不啟用) webpack.config.js 1234567891011121314151617181920212223242526272829303132333435module.exports = { module: { rules: [ { test: /\\.(png|jpe?g|gif|svg|webp)$/i, use: [ // url-loader... { loader: 'image-webpack-loader', options: { disable: process.env.NODE_ENV === 'production' ? false : true, mozjpeg: { progressive: true, quality: 65, }, optipng: { enabled: false, // 表示不啟用這一個圖片優化器 }, pngquant: { quality: [0.65, 0.9], speed: 4, }, gifsicle: { interlaced: false, }, webp: { quality: 75, // 配置選項表示啟用 WebP 優化器 }, }, }, ], }, ], },}; 使用plugin的方式–ImageMinimizerWebpackPlugin 这个插件可以使用两个工具来压缩： imagemin - 默认情况下优化您的图像，因为它稳定且适用于所有类型的图像。1npm install imagemin-gifsicle imagemin-jpegtran imagemin-optipng imagemin-svgo --save-dev 1234567891011121314151617181920212223242526const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);const { extendDefaultPlugins } = require(&quot;svgo&quot;);module.exports = {module: { rules: [ { test: /\\.(jpe?g|png|gif|svg)$/i, type: &quot;asset&quot;, }, ],},plugins: [ new ImageMinimizerPlugin({ minimizerOptions: { //使用自定义选项进行无损优化 //随意尝试各种选项，为您带来更好的结果 plugins: [ [&quot;gifsicle&quot;, { interlaced: true }], [&quot;jpegtran&quot;, { progressive: true }], [&quot;optipng&quot;, { optimizationLevel: 5 }], ], }, }),],}; squoosh - 在实验模式下使用 .jpg 、 .jpeg 、 .png 、 .webp 、 .avif 文件类型1npm install @squoosh/lib --save-dev 1234567891011121314151617const ImageMinimizerPlugin = require(&quot;image-minimizer-webpack-plugin&quot;);module.exports = {module: { rules: [ { test: /\\.(jpe?g|png)$/i, type: &quot;asset&quot;, }, ],},plugins: [ new ImageMinimizerPlugin({ minify: ImageMinimizerPlugin.squooshMinify, }), ],};","link":"/2021/04/02/minizer/"},{"title":"MutationObserver","text":"简介 MutationObserver接口提供了监视对DOM树所做更改的能力。它被设计为旧的Mutation Events功能的替代品，该功能是DOM3 Events规范的一部分。 概念Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。 概念上，它很接近事件，可以理解为 DOM 发生变动就会触发 Mutation Observer 事件。但是，它与事件有一个本质不同：事件是同步触发，也就是说，DOM 的变动立刻会触发相应的事件；Mutation Observer 则是异步触发，DOM 的变动并不会马上触发，而是要等到当前所有 DOM 操作都结束才触发。 构造函数使用时，首先使用MutationObserver构造函数，新建一个观察器实例，同时指定这个实例的回调函数。 1const observer = new MutationObserver(callback); 上面代码中的回调函数，会在每次 DOM 变动后调用。该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例，下面是一个例子。 123456const observer = new MutationObserver((mutations, observer) =&gt; { mutations.forEach((mutation) =&gt; { console.log(mutation); });}); 方法 observe() observe方法用来启动监听，它接受两个参数。 第一个参数：所要观察的DOM节点 第二个参数：一个配置对象，指定所要观察的特定变动 12345678const article = document.querySelector('article');const options = { 'childList': true, 'attributes':true} ;observer.observe(article, options); 上面代码中，observe方法接受两个参数，第一个是所要观察的DOM元素是article，第二个是所要观察的变动类型（子节点变动和属性变动）。 观察器所能观察的 DOM 变动类型（即上面代码的options对象），有以下几种。 childList：布尔值，表示子节点的变动（指新增，删除或者更改）。 attributes：布尔值，表示属性的变动。 characterData：布尔值，表示节点内容或节点文本的变动。 subtree：布尔值，表示是否将该观察器应用于该节点的所有后代节点。 attributeOldValue：布尔值，表示观察attributes变动时，是否需要记录变动前的属性值。 characterDataOldValue：布尔值，表示观察characterData变动时，是否需要记录变动前的值。 attributeFilter：数组，表示需要观察的特定属性（比如['class','src']）。 tips: 想要观察哪一种变动类型，就在 option 对象中指定它的值为 true。需要注意的是，必须同时指定 childList、attributes 和 characterData 中的一种或多种，若均未指定将报错。 下面的例子是观察新增的子节点。 123456789let insertedNodes = [];const observer = new MutationObserver((mutations) =&gt; { mutations.forEach((mutation) =&gt; { for (var i = 0; i &lt; mutation.addedNodes.length; i++) insertedNodes.push(mutation.addedNodes[i]); })});observer.observe(document, { childList: true });console.log(insertedNodes); takeRecords() takeRecords方法用来清除变动记录，即不再处理未处理的变动。该方法返回变动记录的数组。 1observer.takeRecords(); disconnect() disconnect方法用来停止观察。调用该方法后，DOM 再发生变动，也不会触发观察器。 1observer.disconnect(); MutationRecord 对象DOM 每次发生变化，就会生成一条变动记录（MutationRecord 实例）。该实例包含了与变动相关的所有信息。Mutation Observer 处理的就是一个个MutationRecord实例所组成的数组。 MutationRecord对象包含了DOM的相关信息，有如下属性： type：观察的变动类型（attribute、characterData或者childList）。 target：发生变动的DOM节点。 addedNodes：新增的DOM节点。 removedNodes：删除的DOM节点。 previousSibling：前一个同级节点，如果没有则返回null。 nextSibling：下一个同级节点，如果没有则返回null。 attributeName：发生变动的属性。如果设置了attributeFilter，则只返回预先指定的属性。 oldValue：变动前的值。这个属性只对attribute和characterData变动有效，如果发生childList变动，则返回null。 应用示例子元素的变动下面的例子说明如何读取变动记录。 123456789101112131415let callback = function (records){ records.map((record) =&gt; { console.log('Mutation type: ' + record.type); console.log('Mutation target: ' + record.target); });};const mo = new MutationObserver(callback);const option = { 'childList': true, 'subtree': true};mo.observe(document.body, option); 上面代码的观察器，观察&lt;body&gt;的所有下级节点（childList表示观察子节点，subtree表示观察后代节点）的变动。回调函数会在控制台显示所有变动的类型和目标节点。 属性的变动下面的例子说明如何追踪属性的变动。 1234567891011121314151617const callback = function (records) { records.map((record) =&gt; { console.log('Previous attribute value: ' + record.oldValue); });};const mo = new MutationObserver(callback);const element = document.getElementById('#my_element');const options = { 'attributes': true, 'attributeOldValue': true}mo.observe(element, options); 上面代码先设定追踪属性变动（'attributes': true），然后设定记录变动前的值。实际发生变动时，会将变动前的值显示在控制台。 实现水印的不可删除 在实现水印不可删除的过程中，主要需要应对的逻辑有两个： 监听对水印节点的修改 监听对水印节点的删除 监听对水印节点的修改 12345678910111213drawCanvas () { ... ... // 代码省略}canvasObserver() { this.drawCanvas(); let canvasObserver = new MutationObserver((mo) =&gt; { this.drawCnvas(); }); let config = { attributes: true, childList: true, characterData: true }; canvasObserver.observe(document.querySelector('#divContainer'), config);} 监听对水印节点的删除 12345678910111213141516171819drawCanvas () { ... ... // 代码省略}canvasObserver() { this.drawCanvas(); let canvasObserver = new MutationObserver((mo) =&gt; { let { removedNodes } = mo[0]; if (removedNodes.find(target)) { ... ... // 寻找目标节点的伪代码 this.drawCnvas(); } }); let config = { attributes: true, childList: true, characterData: true }; let target = document.querySelector('#divContainer'); canvasObserver.observe(target.parentNode, config);} 参考链接： Mutation Observer API","link":"/2020/02/29/mutation-observer/"},{"title":"npm 和 yarn","text":"记录一下我所了解的npm和yarn的区别。 npm 和 yarn 是什么？npm和yarn都是包管理工具。什么是包管理工具？一个相对复杂的项目中，其实会用到很多依赖包。比方说一个react项目，我们除了会依赖react，可能还有react-dom、react-router、ant-design、axios等，这些包是我们显性依赖的，可以给我们提供UI、请求、工具等功能。然而这些包本身可能也会依赖一些其他的包，这是我们所不了解的。难道我们在开发一个项目，需要开发者去维护这些依赖关系吗？ 为了解决这个问题，包管理工具就应运而生。包管理工具可以帮助开发者去解析和维护项目依赖包的版本迭代、依赖关系等信息。npm和yarn都是这个作用。 为什么需要yarn?npm是最早的包管理工具，也就是先有npm，后有yarn。 为什么已经有了npm，还需要yarn呢？是因为早期的npm存在诸多不如人意之处，比如： 没有很好的管理依赖关系 对于一个直接依赖包A，如果其存在间接依赖a、b，那么在安装依赖包A时，也会把a、b一同安装，并且是安装是依赖包A的目录下，如果间接依赖包a、b仍然需要其他子依赖，则会递归安装。甚至如果直接依赖包B也需要安装子依赖a、b，由于之前的子依赖a、b是安装A目录之下，因此B也会重新在自己的目录下再装一遍。这样就形成依赖地狱，而且整个项目体积非常巨大。 无法确定依赖版本 对于一些没有指定版本的依赖包，通常会按照最新版本进行安装。这样会导致不同开发者在不同时期安装的依赖，版本不一致。 不稳定的加载速度 由于npm对于缓存策略以及包管理方式等问题，导致开发者通过npm形式安装依赖包的时候，可能需要等待很长时间。 以上只是我所知道的一些问题，不完全列举。 为了解决npm存在的问题，Facebook、Google等大厂联合出手，创建了新的包管理工具，即yarn。那么yarn是如何解决上述问题的呢？ 将依赖关系扁平化 不同与上述的依赖包安装方式，不管是直接依赖还是间接依赖，yarn都会尽可能地把所有依赖提升到同一个维度，即所有依赖都共存在同一级目录下。这样可以避免过深的依赖树结构，同时可以尽可能地让不同依赖包可以共享共同的子依赖，避免加载重复的子依赖包。 添加依赖版本的处理逻辑 添加yarn.lock文件，将项目当前所依赖的包版本信息锁定住，如果存在yarn.lock文件，则按照该文件去安装指定的依赖包版本。这样可以让不同开发者在不同时期，还原相同的项目环境。 更好的加载速度 yarn对与依赖包的缓存策略、请求方式等也做了相关的处理，目的是安装依赖包的时候可以更快。 这就是出现yarn的原因。 npm 和 yarn 的差异？如果我们把npm 和 yarn比作竞争对手的话，即然yarn已经指出了npm的毛病并且进行了优化，npm当然也不会这么不思上进不知悔改。所以后期npm也早已修复了上述缺陷。比如npm现在也将依赖关系扁平化，避免了依赖嵌套问题；npm新增了package-lock.json文件，修复了依赖包版本不确定问题；优化加载速度等等。 所以现在的npm在性能和体验方便应该是无限接近于yarn，我们倒也不必认为yarn有绝对优势。 即然这样，为什么还同时存在npm和yarn，岂不是只需存在一个即可？ 对于这个问题，我个人的理解是，对于开发者来说，的确是只需要使用一个即可。但对于包管理厂商来说，它们的存在有它们存在的价值，不会因为竞争对手的存在而放弃自己存在的权利。 并且它们在管理依赖和安装机制的具体实现上，肯定也是不一样的，在此借用一下网上的流程图： npm安装机制 yarn安装机制 npm 和 yarn 能否共存在一个项目？npm 和 yarn 能否共存在一个项目？答案是肯定的，虽然并不建议这么做。 按照我的理解，不管是npm 还是 yarn，所安装的依赖包是同属于一个空间的，即都是存在node_modules目录下，这就为彼此依赖共享提供了可能。那么npm 还是 yarn只需要在下载安装包的时候，检查当前已存在的依赖包，避免重复安装即可。 小结以上只是我对与npm 和 yarn非常浅薄的了解，仅做记录加深自己的印象，远不足以传道解惑。更多问题，在此推荐更好的文章： 字节的一个小问题 npm 和 yarn不一样吗？ 字节的一个小问题npm 和 yarn不一样吗？(续篇)","link":"/2021/04/20/npm-yarn/"},{"title":"预检请求","text":"HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为”*”）使用该方法。 什么是预检请求以上是MDN对于预检请求的描述，但我看得不是很明白，在此用自己的语言来表述一下： 预检请求，是浏览器针对跨域的复杂请求自动发起的请求，对应的请求方式是OPTIONS，在浏览器的请求类型是preflight，其目的是为了获取目标服务器支持哪些请求方式。 什么情况下开启预检请求通过上边的表述，我们可以提取三个有效消息： 浏览器自动发起 针对跨域请求 针对复杂请求 也就是说，只要满足两个条件，跨域请求、复杂请求，那么浏览器就会自动预检请求，而不用前端开发者主动发起。 对于跨域请求不用解释，那什么是复杂请求呢？ 即然有复杂请求，肯定就会有简单请求，先说说这两者的关系： 简单请求 请求方法为GET、HEAD、POST； 人为设置了规范集合之内的首部字段，如Accept/Accept-Language/Content-Language/Content-Type/DPR/Downlink/Save-Data/Viewport-Width/Width； Content-Type 的值仅限于下列三者之一，即 application/x-www-form-urlencoded、multipart/form-data、text/plain； 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； 请求中没有使用 ReadableStream 对象； 复杂请求 使用了下面任一 HTTP 方法，PUT/DELETE/CONNECT/OPTIONS/TRACE/PATCH 人为设置了以下集合之外首部字段，即简单请求外的字段 Content-Type 的值不属于下列之一，即application/x-www-form-urlencoded、multipart/form-data、text/plain 上边信息太多，看不太懂，但有两个信息是我们经常会用到的，那就是请求方法和Content-Type。请求方法不用多说，至于Content-Type，上述信息中，缺少一个我们常见的类型，即application/json。 也就是说，我们平时经常看到的，请求头里包含content-type: application/json的请求，即为复杂请求。 针对上述表述，我不是很确定。我通过随机查看某一站点的请求，发现不管是GET或是POST, 只要请求头里包含content-type: application/json，那么该请求就会发起预检请求。由此我判断，只有符合上述关于简单请求的所有条件，才是一个简单请求，反之则是复杂请求。 如何避免预检请求设想如果所有请求都先默认发起一个预检请求，得到回复后再发起一个实际请求，那必然是会影响请求效率，那该如何避免/减少预检请求呢？ 全部使用简单请求 上文已经说到，针对跨域的复杂请求才会发起预检，是否跨域不由我们控制，那我们能否全都改成简单请求？实际上应该不太可能，或则说代价比较大，想想如果我们不能设置content-type: application/json，那前端对于服务端返回的数据，是不是要进行额外的解析处理？这并不是我们想要的。 设置Access-Control-Max-Age 这个使用的http缓存的原理，即当我们首次发起预检请求之后，如果设置Access-Control-Max-Age，那么会在响应头里给我返回有效时间，只要是在有效时间之内，再次发起请求的时候，就不会主动触发预检请求了。 思考说了那么多，其实我还是不太了解预检请求的作用。为什么需要多发一个请求去获取目标服务器支持哪些请求方式？我们直接当作简单请求发起，如果服务器不支持该请求的话，再给我们返回特定的code不可以吗？ 希望有缘人能够解答。","link":"/2021/04/20/preflight/"},{"title":"进程和线程","text":"进程进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的的基本单位，是操作系统的基础，是程序是的实体，是线程的容器。 线程 线程（thread）是程序执行的最小的单位 线程是进程的一个实体，是被系统调度和分派的基本单位 线程不拥有系统资源，它与同属一个进程的其他线程共享进程所拥有的全部资源 一个线程可以创建和撤销另一个线程，同一个进程的多个线程之间可以并发执行 由于线程之间的互相制约，致使线程在运行中呈现出间断性 一个标准的线程包括：线程ID、当前指令指针（PC）、寄存器集合、 堆栈 线程包含就绪、阻塞、运行三种状态 进程和线程的区别 地址空间和其他资源：进程间相互独立，同一进程的各个线程共享资源。某进程内的线程在其他进程不可见。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。 调度和切换：线程上下文切换比进程上下文切换要快很多。 在多线程OS中，进程不是一个可执行的实体。 多进程和多线程的比较 对比维度 多进程 多线程 总结 数据共享、同步 数据共享复杂，需要用IPC；数据是分开的，同步简单 共享进程数据，共享简单，同步复杂 各有优势 内存、CPU 占用内存多，切换复杂，CPU利用率低 占用内存少，切换简单，CPU利用率高 线程占优 创建销毁、切换 创建销毁、切换复杂，速度慢 创建销毁、切换简单，速度快 线程占优 编程、调试 编程简单，调试简单 编程复杂，调试复杂 进程占优 可靠性 进程间不会互相影响 一个线程挂掉将导致整个进程挂掉 进程占优 分布式 适应多核、多机分布式；如果一台及其不够，扩展到多台机器比较简单 适应多核分布式 进程占优 通信进程间的通信进程间通信是指在不同进程之间传播或交换信息。IPC(InterProcess Communication)的方式通常有管道、消息队列、信号量、共享存储、Socket、Streams等。其中Socket和Streams支持不同主机上的两个进程IPC。 管道： 速度慢，容量有限，只有父子进程能通讯； FIFO： 任何进程都能通讯，但速度慢； 消息队列： 容量收到系统限制，且要注意第一次读的时间，要考虑上一次没有读完数据的问题； 信号量：不能传递复杂消息，只能用来同步； 共享内存区： 能够狠容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全。 线程间的通信 使用全局变量（窗体不适用） 使用自定义消息（窗体适用） 使用事件内核对象 并发与并行并发在操作系统中，并发是指一个时间段中有几个程序都处于已经启动运行到运行完毕的状态之间，且这几个程序都是在同一个处理机上运行。其中并发关系可以分为两种： 互斥： 进程间互相排斥的使用临界资源的现象，称为互斥； 同步： 进程间不排斥使用临界资源，而是相互依赖，前一个进程的输出作为后一个进程的输入，当前一个线程没有输出时，第二个线程必须等待。 并行在单处理器的多道程序设计系统中，进程被交替执行，表现出一种并发的外部特征； 在多处理器系统中，进程不仅可以交替执行，还可以重叠执行。在多处理器上的程序才可以实现并行处理。 从而可知，并行是针对多处理器而言的，并行是同时发生多个并发事件，具有并发的含义，但并发并不一定并行，或说并发事件之间不以帝国要同一时刻发生。","link":"/2020/07/20/process-thread/"},{"title":"JS原型与原型链","text":"普通对象与函数对象凡是通过 new Function()创建的对象都是函数对象，其他的是普通对象。 123456789101112131415161718var o1 = {};var o2 =new Object();var o3 = new f1();function f1(){};var f2 = function(){};var f3 = new Function('str','console.log(str)');console.log(typeof Object); //functionconsole.log(typeof Function); //functionconsole.log(typeof f1); //functionconsole.log(typeof f2); //functionconsole.log(typeof f3); //functionconsole.log(typeof o1); //objectconsole.log(typeof o2); //objectconsole.log(typeof o3); //object 以上例子中，o1、o2、o3 均为普通对象(实例对象)，f1、f2、f3 均为函数对象(抽象对象) 构造函数任何一个实例都有一个constructor（构造函数）属性，该属性（是一个指针）指向了实例的构造函数。即实例的 constructor === 构造函数 12345678910function Person(name, age, job) { this.name = name; this.age = age; this.job = job; this.sayName = function() { alert(this.name); };}var person1 = new Person(&quot;Zaxlct&quot;, 28, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Mick&quot;, 23, &quot;Doctor&quot;); 123console.log(person1.constructor == Person); //trueconsole.log(person2.constructor == Person); //true 原型对象每个对象都有 __proto__ 属性，但只有函数对象才有 prototype 属性。函数对象的 prototype 指向函数的原型对象。换而言之,只有函数对象才存在原型对象，函数对象的 prototype 属性指向了其原型对象。 举个例子 123function Person() {}Person.prototype.name = &quot;linlin&quot;;Person.prototype.age = 25; 以上代码完全等价于 12345function Person() {}Person.prototype = { name: &quot;linlin&quot;, age: 25}; 由于函数对象的 prototype 属性指向的是其原型对象，而上述例子中，Person.prototype 指向的是一个普通对象{name: 'linlin', age: 25}，由此我们可知，原型对象是一个普通函数。 所有的原型对象都有一个constructor（构造函数）属性，这个属性是一个指针，指向prototype属性所在的函数。 即 1Person.prototype.constructor == Person 联系之前知识，实例的 constructor === 构造函数，在此我们可以将 Person.prototype 当成 Person 的一个实例 person1，于是以上代码可看作是等价如下: 1person1.constructor == Person; 也就是在 Person 创建的时候，创建了一个它的实例化对象并且赋值给它的 prototype，基本过程如下： 12var A = new Person();Person.prototype = A; 结论：原型对象(Person.prototype)是构造函数(Person)的一个实例。 原型对象的主要作用是用于继承。所有定义在原型对象上的属性，都可以被构造函数实例化的对象继承。 __proto__JS 在创建对象的时候，不管是普通对象还是函数对象，都会内置一个叫做**__proto__**的属性，用于指向创建它的构造函数的原型对象。 12var person = new Person();person._proto_ === Person.prototype; 需要注意的是，这种指向关系存在于实例(person)和构造函数的原型对象(Person.prototype)之间，而非实例(person)于构造函数(Person)之间。 PrototypePrototype是保存一个函数对象所有方法的真正存在，换句话说，当我们定一个函数对象的时候，该函数对象的所有方法和属性其实是保存在该对象的prototype属性上，而非存在于函数本身。以下例子可以说明： 123456789101112131415function Person(age) { this.name = &quot;person&quot;; this.age = age;}Person.prototype.sex = &quot;male&quot;;var p = new Person(10);console.log(Person.name); //undifinedconsole.log(Person.age); //undifinedconsole.log(Person.sex); //undifinedconsole.log(p.name); //'person'console.log(p.age); //10console.log(p.sex); //'male' 可以看出，我们无法直接获取到函数对象的任何属性，是因为所有属性存在于函数对象的prototype属性上，而非存在于函数本身，而使用实例对象直接访问到函数对象的所有属性，这是因为实例对象的__proto__属性指向的是其构造函数的是原型对象，即构造函数的prototype，通过原型链就可以访问到prototype上的所有属性。 原型链当查找一个实例的属性时，会先从这个实例的自定义属性上查找，如果没有的话，会通过__proto__去实例所属的类的原型（实例的构造函数）上找，如果还没有的话，就会通过原型的__proto__到Object的原型上去找，如此层层往上，直到__proto__指向的是 null。这种通过__proto__在对象之间构成的关系，就称为原型链。 如果实例和原型都共存一个相同的属性，在访问该属性时，指向的是实例上的属性，而非原型上的属性，这种情况称为属性遮蔽。如下 1234567891011121314function Fn() { this.a = 1; this.b = 2;}Fn.prototype.b = 3;Fn.prototype.c = 4;var f = new Fn();console.log(f.a); // a是自身属性，该属性的值为1console.log(f.b); // b是自身属性，该属性的值为2，原型上也有属性'b'，但由于“属性遮蔽”所以无法访问console.log(f.c); // c不是自身属性，会通过原型链往它的原型上去查找，而原型上有属性‘c’,该属性的值为4console.log(f.d); // d不是自身属性，会通过 原型链是指对象之间通过__proto__建立起来的指向关系，所以原型链的形成依靠的是__proto__,而非prototype","link":"/2020/03/04/prototype/"},{"title":"Proxy","text":"Proxy是ES6新增的一种操作对象的API，用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。 语法 let p = new Proxy(target, handler); 参数 target 用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。 handler 一个对象，其属性是当执行一个操作时定义代理的行为的函数。 方法Proxy有13种数据劫持的操作。 方法 描述 get 获取某个key值 set 设置某个key值 has 使用in操作符判断某个key是否存在 apply 函数调用，仅在代理对象为function时有效 ownKeys 获取目标对象所有的key construct 函数通过实例话调用，仅在代理对象为function时有效 isExtensible 判断对象是否可扩展 deleteProperty 删除某一个property defineProperty 定义一个新的property getPrototypeOf 获取原型对象 setPrototypeOf 设置原型对象 preventExtensions 设置对象为不可扩展 getOwnPropertyDescriptor 获取一个自有属性(非原型连上的属性)的属性描述 get get方法是你在得到某个对象属性值时预处理的方法，接受两个常用参数 target：得到的目标值 key：对象的属性 12345678910111213141516let Bao = { name: 'LV', price: 9999};let proxy = new Proxy(Bao, { get: function (target, key) { if (target['price'] &gt; 5000) { return '超出客户心理价位' } else { return '符合客户心理价位' } }});proxy.price; // 超出客户心理价位 set set方法用来拦截某个属性的赋值操作，可以接受四个参数 target: 目标值 key: 对象属性 value: 对象属性值 receiver: 改变前的原始值 12345678910111213141516171819202122let validator = { set: function(target, key, value) { if (key === 'age') { if (!Number.isInteger(value)) { throw new TypeError('The age is not an integer'); } if (value &gt; 200) { throw new RangeError('The age seems invalid'); } } target[key] = value; }};let person = new Proxy({}, validator);person.age = 100;person.age; // 100person.age = 'young' // he age is not an integerperson.age = 300 // The age seems invalid Proxy相比Object.defineProperty的优势 支持数组 123456789101112131415161718let arr = [1,2,3]let proxy = new Proxy(arr, { get (target, key, receiver) { console.log('get', key) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log('set', key, value) return Reflect.set(target, key, value, receiver) }})proxy.push(4)// 能够打印出很多内容// get push (寻找 proxy.push 方法)// get length (获取当前的 length)// set 3 4 (设置 proxy[3] = 4)// set length 4 (设置 proxy.length = 4) 针对对象 与Object.defineProperty()方法不同，Proxy针对的是完整的对象，而不是对象的某个属性，所以不需要对keys进行遍历。 1234567891011121314151617let obj = { name: 'Eason', age: 30}let handler = { get (target, key, receiver) { console.log('get', key) return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log('set', key, value) return Reflect.set(target, key, value, receiver) }}let proxy = new Proxy(obj, handler)proxy.name = 'Zoe' // set name Zoeproxy.age = 18 // set age 18 嵌套支持 Proxy本质上是不支持嵌套的。可以通过在get方法里边递归调用Proxy来实现。 123456789101112131415161718192021222324let obj = { info: { name: 'eason', blogs: ['webpack', 'babel', 'cache'] }}let handler = { get (target, key, receiver) { console.log('get', key) // 递归创建并返回 if (typeof target[key] === 'object' &amp;&amp; target[key] !== null) { return new Proxy(target[key], handler) } return Reflect.get(target, key, receiver) }, set (target, key, value, receiver) { console.log('set', key, value) return Reflect.set(target, key, value, receiver) }}let proxy = new Proxy(obj, handler)// 以下两句都能够进入 setproxy.info.name = 'Zoe'proxy.info.blogs.push('proxy') 应用实例使用Proxy实现表单校验 123456789101112131415161718let person = { name: 'xiaoming', age: 30}let handler = { set (target, key, value, receiver) { if (key === 'name' &amp;&amp; typeof value !== 'string') { throw new Error('用户姓名必须是字符串类型') } if (key === 'age' &amp;&amp; typeof value !== 'number') { throw new Error('用户年龄必须是数字类型') } return Reflect.set(target, key, value, receiver) }}let boy = new Proxy(person, handler)boy.name = 'xiaohong' // OKboy.age = '18' // 报错 用户年龄必须是数字类型 参考链接： Proxy ES6-Proxy与数据劫持","link":"/2020/03/04/proxy/"},{"title":"Reflect","text":"ES6中将Object的一些明显属于语言内部的方法移植到了Reflect对象上，未来的心方法只部署在Reflect对象上。 Reflect对象对某些方法的返回结果进行了修改，使其更合理。 Reflect对象使用函数的方式实现了Object的命令式操作。 为什么使用Reflect1. 更有用的返回值Reflect对象的方法调用结果是一个Boolean值，不会像Object的方法一样返回obj。 我们可以对如下代码进行重构： 123456try {Object.defineProperty(obj, name, desc); // property defined successfully} catch (e) { // possible failure (and might accidentally catch the wrong exception)} 重构成这样： 12345if (Reflect.defineProperty(obj, name, desc)) { // success} else { // failure} 2. 更好的操作方式Reflect对象帮我们封装好了一些常用方法，像Math对象一样，我们可以可以直接调用其静态方法。 如: 12345// 删除属性delete obj[name]// 判断属性是否存在name in obj 可以改写成: 12345// 删除属性Reflect.deleteProperty(obj, name)// 判断属性是否存在Reflect.has(obj, name) 3.更可靠的函数时执行方式在ES5中，如果要执行一个函数f，并且传给它一组参数args，还要绑定this的话，通常这样写： 1f.apply(obj, args) 但是f的apply方法可能被重新定义了，所以比较可靠的写法是： 1Function.prototype.apply.call(f, obj, args) 上面这段代码太长，显得不够优雅，我们可以使用Reflect更简洁的实现： 1Reflect.apply(f, obj, args) 4. 可变参数形式的构造函数在ES5中，实例化函数方法如下： 1var obj = new F(...args) 或者 1var obj = F.apply(this, args) 不过ES5不支持扩展符，并且当F是一个构造函数的时候，就会显得捉襟见肘。 但是在ES6中我们可以这样写： 1let obj = Reflect.construct(F, args) 5. 控制访问起活着读取器的this在ES5中，读取或设置属性需要这样做： 12var name = obj['name']; // 读取属性obj['name'] = 'Jerry' // 设置属性 我和可以使用Reflect.set()方法实现同样的事情，并且增加而外的参数recover，这样允许我们设置对象的setter和getter的上下文this： 12345678910111213141516171819var obj = { set foo(value) { return this.bar(); }, bar: function() { alert(1); }};var wrapper = { bar: function() { console.log(&quot;wrapper&quot;); }}Reflect.set(obj, &quot;foo&quot;, &quot;value&quot;, wrapper);// 当我们设置 foo 属性的时候，触发了 this.bar() 函数// 此时的 this 指向了 wrapper// 所以触发的是 wrapper.bar() 函数// 因此输出结果是 'wrapper' 6. 避免直接访问__proto__我们可以使用Reflect.getPrototypeOf(obj) 和 Reflect.setPrototypeOf(obj, newProto)方法去访问和设置对象的原型 方法Reflect对象的方法和Proxy对象的方法一一对应，所以Proxy对象的方法可以通过调用Reflect对象的方法取默认行为，然后进行额外操作。 方法 描述 get 获取某个key值 set 设置某个key值 has 使用in操作符判断某个key是否存在 apply 函数调用，仅在代理对象为function时有效 ownKeys 获取目标对象所有的key construct 函数通过实例话调用，仅在代理对象为function时有效 isExtensible 判断对象是否可扩展 deleteProperty 删除某一个property defineProperty 定义一个新的property getPrototypeOf 获取原型对象 setPrototypeOf 设置原型对象 preventExtensions 设置对象为不可扩展 getOwnPropertyDescriptor 获取一个自有属性(非原型连上的属性)的属性描述 参考链接： ES6 Reflect与Proxy Javascript中Reflect对象详解","link":"/2020/03/05/reflect/"},{"title":"谈谈哈希路由和历史路由","text":"前端路由一般分为哈希路由（hash模式）和历史路由（history模式）两种，在Vue、React等主流开发框架中，都支持这两种路由模式的选择。在此深入去了解一下两者的区别。 哈希路由哈希路由会在URL链接上带有#号，这是最表象的特点，而哈希(hash)就是指URL链接尾巴上的#号以及#号后面的字符。 哈希路由是通过监听hashchange事件来实现的。当页面的hash发生变化时，会触发hashchange事件。 hash值的变化并不会导致浏览器向服务器发出请求，页面也不会重新加载。 以下是哈希路由的实现方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243class HashRouter { currentUrl = ''; // 当前URL handlers = {}; constructor() { this.refresh = this.refresh.bind(this); window.addEventListener('load', this.refresh, false); window.addEventListener('hashchange', this.refresh, false); } // 获取哈希值 getHashPath(url) { const index = url.indexOf('#'); if (index &gt;= 0) { return url.slice(index + 1) } return '/' } refresh(event) { let curURL = '', oldURL = null; if (event.newURL) { oldURL = this.getHashPath(event.oldURL || ''); curURL = this.getHashPath(event.newURL || ''); } else { curURL = this.getHashPath(window.location.hash); } this.currentURL = curURL; this.emit('change', curURL, oldURL); } on(evName, listener) { this.handlers[evName] = listener; } emit(evName, ...args) { const handler = this.handler[evName]; if (handler) { handler(...args) } }} 历史路由与哈希路由不同，历史路由在URL链接上不会带有#号，它主要依靠pushState和replaceState两个方法去实现路由功能。 在调用back()、forward()、go()、pushState()、replaceState()等方法时，都只会修改当前的URL, 不会向服务器发起请求，页面内容也不会发生变化。 历史路由是通过根路由去分发到相应路由的，如果在子路由的链接下刷新页面，服务器就会将当前子路游链接当作是根路由链接，自然就无法匹配到响应的页面资源，因而404。因此在使用历史路由模式时，还需要nginx配置来辅助，在当前路由无法访问资源的时候，反向代理到根路由，从而实现根路由到子路由的重新分发。 以下是历史路由的实现方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243class HistoryRouter { currentUrl = ''; handlers = {}; constructor() { this.refresh = this.refresh.bind(this); this.addStateListener(); window.addEventListener('load', this.refresh, false); window.addEventListener('popstate', this.refresh, false); window.addEventListener('pushState', this.refresh, false); window.addEventListener('replaceState', this.refresh, false); } addStateListener() { const listener = function(type) { const orig = history[type]; return function() { const rv = orig.apply(this, arguments); const e = new Event(type); e.arguments = arguments; window.dispatchEvent(e); return rv; } } window.history.pushState = listener('pushState'); window.history.replaceState = listener('replaceState'); } refresh(event) { this.currentUrl = location.pathname; this.emit('change', location.pathname); } on(evName, listener) { this.handles[evName] = listener; } emit(evName, ...args) { const handler = this.handlers[evName]; handler &amp;&amp; handler(...args) }} 总结哈希路由的通用性好、兼容性好（兼容到IE8），且不需要服务器配置，而历史路由兼容性相对差（只兼容到IE10），且需要服务器配置才能使用，为什么不能单纯使用哈希路由? 这是因为，哈希本来是用做页面锚点定位来使用的，将其用作路由的话，原本的锚点功能就不能用了；其次，哈希的传参是基于URL的，如果需要传入复杂数据，会有体积的限制，且链接不够优雅，而历史路由模式除了URL传参，还可以使用特定对象保存参数，从而确保传参的完整性和链接的优雅。","link":"/2021/02/09/router/"},{"title":"十大经典排序","text":"冒泡排序 算法简介冒泡排序是一种简单的的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的排序错误就交换它们的位置。走访数列的工作是重复地进行直到没有需要交换，也就是说数列已经完成排序了。这个算法的名字由来是因为越小的元素就经由交换慢慢的“浮”到数列的顶端。 算法描述 比较相邻的元素，如果第一个比第二个大，就交换它们的位置； 对每一对相邻的元素作同样的工作，从第一对到结尾的最后一对，理论上在最后的元素应该是最大的数； 针对所有元素重复以上的步骤，除了最后一个(因为每次循环中，最后一个数都是最大的数)； 重复步骤 1 ～ 3，直到排序完成。 算法实现1234567891011function bubbleSort(arr) { let len = arr.length; for (let i = 0; i &lt; len; i++) { for (let j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } } return arr;} tips: 设置一标志位pos，用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后非记录均已交换到位，故在进行下一趟排序时只要扫描到pos的位置即可。 改进后的算法如下： 123456789101112131415function bubbbleSort2(arr) { let i = arr.length - 1; //初始时，最后位置保持不变 while (i &gt; 0) { let pos = 0; //每趟开始时，无记录交换 for (let j = 0; j &lt; i; j++) { if (arr[j] &gt; arr[j + 1]) { pos = j; // 记录交换位置 [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } i = pos; } } s; return arr;} tips: 传统冒泡排序中，每一趟排序操作只能找到一个最大值或最小值，我们可以利用在每趟排序中进行正向和反向两遍冒泡的方法一次得到两个最终值（最大值和最小值），从而使循环次数几乎减少一半。 改进后的算法如下： 123456789101112131415161718192021222324252627282930313233function bubbleSort3(arr) { let low = 0; let high = arr.length - 1; let j; while(low &lt; high) { for (j=low; j&lt;high; ++j) { // 正向冒泡，找最大值 if（arr[j] &gt; arr[j+1]）{ [ arr[j], arr[j+1] ] = [ arr[j+1], arr[j] ] } -- high; } for (j=high; j&gt;low; --j) { if (arr[j] &lt; arr[j-1]) { [ arr[j], arr[j-1] ] = [ arr[j-1], arr[j] ] } ++ low; } } return arr;} 算法分析 最佳情况：T(n) = O(n) 当输入的数据已经是正序时 最差情况：T(n) = O(n2) 当输入的数据是反序时 平均情况：T(n) = O(n2) 选择排序算法简介选择排序是一种简单直观的排序算法，也是表现最稳定的排序算法之一。它的工作原理：首先在未排序序列中找到最小的元素，存放到排序序列的起始位置，然后再从剩余的未排序元素中继续寻找最小元素，然后放在已排序元素的末尾。以此类推，知道所有元素均排序完毕。 算法描述n 个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下： 初始状态：无序区为 R[1,…n]，有序区为空； 第 i 趟排序(i=1,2,3,…n-1)开始时，当前有序区和无序区分别为 R[1,…i-1]和 R[i,…n]。该趟排序从当前无序区中选出关键字最小记录 R[k]，将它与无序区的第 1 个记录 R 交换，使 R[1,…i]和 R[i+1,…n]分别为记录个数增加 1 哥的新有序区和记录个数减少一个的新无序区； 重复步骤 2，n-1 趟结束，得到有序数组。 算法实现1234567891011121314function selectionSort(arr) { let len = arr.length; let minIndex, temp; for (let i = 0; i &lt; len - 1; i++) { minIndex = i; for (let j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { minIdex = j; } } [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; } return arr;} 算法分析 最佳情况：T(n) = O(n2) 最差情况：T(n) = O(n2) 平均情况：T(n) = O(n2) 插入排序算法简介插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序(即只需用到 O(1)的额外空间的排序)，因而在从后向前的扫描过程中，需要反复把已排序的元素逐步向后挪位，为最新元素提供插入空间。 算法描述一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可认为是已排序元素； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序元素）大于新元素，将新元素移到下一位置； 重复步骤 3，直到找到已排序元素小于或则等于新元素的位置； 将新元素插入到该位置； 重复步骤 2 ～ 5. 算法实现123456789101112function insertionSort(arr) { for (let i = 1; i &lt; arr.length; i++) { let key = arr[i]; let j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = key; } return arr;} tips: 查找插入位置时使用二分查找可以提高效率 1234567891011121314151617181920function binaryInsertionSort(arr) { for (let i = 1; i &lt; arr.length; i++) { let key = arr[i]; let left = 0; let right = i - 1; while (left &lt;= right) { let middle = parserInt((left + right) / 2); if (key &lt; arr[middle]) { right = middle - 1; } else { left = middle + 1; } } for (let j = i - 1; j &gt;= left; j--) { arr[j + 1] = arr[j]; } arr[left] = key; } return arr;} 算法分析 最佳情况：T(n) = O(n2) 输入数组按升序排序 最差情况：T(n) = O(n2) 输入数组按降序排序 平均情况：T(n) = O(n2)","link":"/2020/02/24/sorting/"},{"title":"大话单点登录","text":"说说单点登录。 什么是单点登录？ 单点登录（Single Sign On），简称为 SSO，是比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。 以上是百度百科对单点登录的解释。通俗的说，就是我们希望在众多网站中，只要在其中一个网站登录过了，再去访问其他网站的时候，可以把我们之前的登录状态给带过去，免得我们每次新访问一个网站的时候都要重新再登录一遍。这就是单点登录。 而目前的单点登录，其实还分为两个概念，即同域名单点登录和不同域名单点登录： 同域名单点登录：要求应用系统建立在同一个父级域名下，如tieba.baidu.com和map.baidu.com，它们有着共同的父级域名，即baidu.com; 不同域名单点登」：各个应用系统不要求建立在同一个域名下，如map.baidu.com和mall.jd.com，它们的子级域名、父级域名都毫无关联，但是我们希望它们也可以加入到单点登陆的应用体系中。 同域名单点登录 同域名下的单点登陆，要求所有应用系统都建立在同一个父级域名。它的原理是，cookie的domain属性可以设置为当前域的父域，并且父域的cookie会被子域所共享。 如上所述，同域名单点登录就是利用了二级域名可以读取顶级域名cookie的原理。这是目前企业使用最广泛也最简单的一种方式，不多赘述。 不同域名单点登录不同域名的单点登录，实现方式有多种，在此仅谈我所了解的一种方式。 我们可以借助sso认证中心来实现不同域名的单点登录。 登录 如同https协议需要一个公信机构来颁发https证书一样，不同站点的单点登录也需要一个第三方站点，即sso认证中心，来管理登录信息。当访问任意站点时，目标站点若未获取到相关的cookie信息，则会给sso认证中心发送请求，让sso认证中心帮忙查看用户的登录状态。 假如sso认证中心查到的用户状态是未登录，则会给目标站点返回指定信息，目标站点在收到这个指定信息后，就会弹出登录页面，让用户输入登录信息。值得注意的是，在用户输完登录信息后，目标站点是不会去校验登录信息的准确性的，而是把这些信息发给sso认证中心，让sso认证中心去完成校验工作。 这样做的目的，是为了让sso认证中心有足够的状态管理权限，当有其他站点再来询问sso认证中心关于用户的登录状态时，sso认证中心可以直接返回状态信息。 回到正题，当sso认证中心收到用户的登录信息并校验通过后，就会创建一个授权令牌然后发送给目标站点。目标站点在收到授权令牌的时候，还会再次跟sso认证中心验证一下授权令牌的准确性，这样做的目的是防止令牌在发送过程中被拦截篡改。而当得到sso认证中心的确认之后，目标站点则允许用户登录，返回有效的登录信息。用户登录成功后，再次访问同一个目标站点时，自然就会带上这个站点cookie等信息，目标站点一旦校验信息通过，就直接允许用户登录了，而不用像之前一样再去询问sso认证中心。 那么在站点A登录之后，再去访问站点B，凭啥站点B就能知道用户已经在站点A登录过了呢？其实站点B并不需要关注用户是否在站点A登录，同理，站点C也不需要了解用户是否在B处登录过……所有站点只需要关注一个对象，那就是sso认证中心。只要目标站点获取不到用户相关的登录信息，都会转向sso认证中心去查询登录状态。 上文已经说过了当sso认证中心查询到未登录时是如何操作的了，那么当站点B或站点C查询不到登录态时，就会转向sso认证中心去查询，可以理解为是重定向到sso认证中心。即然是重定向到sso认证中心，那么我们可以把它当作是用户主动请求sso认证中心一样来看待。这时候的sso认证中心就跟任何一个普通站点是一样了，请求自然也会带上与sso认证中心相关的cookie。只要验证到了登录状态有效，sso认证中心就会给目标站点发送相关的授权令牌，这就又回到了上文一样的流程。 这就是不同域名单点登录的问题。 注销 如何实现单点注销呢？即用户在站点A退出登录后，站点B和C也跟着退出呢？其实比单点登录更简单。当用户在站点A退出登录时，站点A也会给sso认证中心发送一个注销请求，sso认证中心收到这个请求后，就会退出用户在sso认证中心的登录态，同时会给所有与sso认证中心维持关系的站点发送退出登录通知，即sso认证中心会给站点A、B、C…发送退出登录通知。这些站点收到这个通知后，直接退出用户的登录态即可。 切换身份 那么问题来了，假如用户在站点A不退出，而是切换了账号，即从张三这个身份切成李四，这时候再去访问站点B，那么站点B到底是继续显示张三呢，还是李四呢？ 关于这个问题，我没有找到答案。不过按理来说，肯定是需要切换成李四才行，不然同一个用户（假如他有多个账号），在其他站点切换身份后，结果访问A时是张三，访问B时是李四，访问C时是王五，这不得搞个精神分裂？ 那如何才能保持单点切换身份，其他站点也跟着切换呢？以下纯属个人臆想。 我觉得就跟单点注销一样，单点切换时，站点也可以给sso认证中心发送切换账号的请求，sso认证中心收到这个请求后，首先会在sso认证中心本地完成身份切换，切换成功后，再往各个站点发送通知，说“之前给你们发送的授权令牌已经不生效了啊，如果下次用户再拿这个令牌来访问，你们就不要让他登录了，把那个令牌没收起来交给我，到时候我再给你们换成新的。” 各站点收到sso认证中心老大哥的命令后，就会更新自己的信息，当用户继续拿着旧cookie来访问站点时，发现已经匹配不上了呀，这时候只能回到sso认证中心，sso认证中心校验通过后，再给目标站单颁发新的令牌，也就是用户新的身份。 小结以上是我对单点登录的理解，学疏才浅，或有不妥之处。尤其是切换身份这个操作，完全是个人猜测。但觉得有一定的道理，所以记录在此。","link":"/2021/04/06/sso/"},{"title":"什么是虚拟DOM","text":"虚拟DOM的本质是用js对象来表示页面上的元素，并提供了操作DOM对象的API DOM树的概念一个网页的呈现过程： 浏览器请求服务器获取页面的HTML结构； 浏览器在内存中，解析DOM结构，并且在浏览器内存中渲染出一颗DOM树； 浏览器把DOM树呈现在页面上。 虚拟DOM虚拟DOM指的是用js对象的形式，来模拟页面上DOM的嵌套关系。 例如： 1234&lt;div id=&quot;name&quot; title=&quot;name&quot;&gt; hello world &lt;p&gt;i am coming&lt;/p&gt;&lt;/div&gt; 对应的虚拟DOM是： 123456789101112131415const div = { tagName: 'div', attrs: { id: 'name', title: 'name' }, children: [ 'hello world', { tagName: 'p', attrs: {}, children: ['i am coming'] } ]} 为什么需要虚拟DOM在React、Vue等技术出现之前，我们要改变页面展示的内容，只能通过遍历查询DOM树的方式来找到需要修改的DOM，然后修改样式、行为或则结构，以此来达到更新UI的目的。 这种方式非常消耗计算资源，原因有二： DOM树的实现模块和JS模块是分开的，跨模块的通讯增加了成本； DOM操作会因此浏览器的回流和重绘,增加渲染成本。 我们可以将DOM模块和JS模块比喻成两个目的地，中间有一条桥梁将二者连接，每实现一次JS模块对DOM模块的操作，都需要交一次过桥费。因此这样的操作越多，代价越大。 虚拟DOM渲染示例 创建一个虚拟DOM: 12345678910111213141516171819202122const HelloWorld = { nodeName:'div', attrs:{ className:'', }, css:{ width: '100px', height: '40px', color: 'green' }, events:{ onclick:()=&gt;{ console.log('Hello virtual DOM') } }, childrens:[ { nodeName:'text', attrs:{ innerText:'HelloWorld', }, } ]} 解析虚拟DOM 12345678910111213141516171819202122232425262728293031function render(vNode) { // 创建dom const dom = document.createElement(vNode.nodeName) const { attrs, css, events, childrens } = vNode // 添加属性 for(const attrName in attrs){ dom[attrName] = attrs[attrName] } // 添加行内样式 for(const attrName in css){ dom.style[attrName] = css[attrName] } // 添加事件 for(const eventName in events){ dom[eventName] = events[eventName] } if(childrens){ for(const children of childrens) { // 生成子节点 const childrenNode = render(children) // 绑定子节点 dom.append(childrenNode) } } return dom} 渲染虚拟DOM 12const dom = render(HelloWorld)document.body.append(dom) 参考链接： 什么是虚拟DOM","link":"/2020/03/01/virtual-dom/"},{"title":"谈谈Vue双向绑定的设计思想","text":"曾经在面试中被提问“Vue双向绑定的原理是什么？”，当时脱口而出的是“数据劫持和订阅发布”，而面试官继续追问“为什么需要订阅发布呢？”，这个问题当时把我问倒了。对啊，为什么需要订阅发布呢？为什么不在数据劫持的getter和setter勾子里直接去触发视图更新函数呢？聊聊我自己的看法。 首先说一下什么是双向绑定? 双向绑定指的是视图层(View)的变化会引起数据层(Data)的变化，同时数据层(Data)的变化也会引起视图层(View)的变化。这分为两个环节： 视图层(View) -&gt; 数据层(Data) 数据层(Data) -&gt; 视图层(View) 视图层(View)到数据层(Data)的变化是通过监听事件来实现的，比如input的onChange事件，通过监听事件去触发数据层的更新，这很好理解，在此不多加累述。 重点说说数据层(Data)到视图层(View)的变化。 我们都知道Vue双向绑定借助了数据劫持的原理，所谓的数据劫持，劫持的是什么数据呢？答案是data。Vue通过遍历和递归，对data对象的每个属性值都进行了劫持，任何数据读取和变更都会触发getter、setter，但是并非每一个data属性值都会映射到视图层，或则一个data属性值可能会映射到多处视图层， 那么我们如何去判断哪些数据变更需要触发视图的更新呢？显然，如果我们直接在getter和setter勾子里去触发相关函数的话，就需要添加很多的判断逻辑，这是极不优雅也不合理的。 为了更好的管理这些逻辑关系，Vue使用了订阅发布模式。具体是怎么一回事呢，我们来聊聊。 上文已经提到，有一类data属性值不会映射到视图层，另一类是会映射到视图层，为了去区分这两者，我们引入一个概念，订阅者(Watcher)，将每个映射到视图层的data属性值都看作一个订阅者(Watcher)。当触发到setter勾子的时候，就去通知对应的订阅者(Watcher)，让其更新操作；而非订阅者(Watcher)对应的属性发生变更时，setter就不需要发出通知。 这样就完成了数据劫持环节与视图更新环节的解耦。 这样就够了吗？我们忽略了一个问题，就说上文说到的一个data属性值可能会映射到多处视图层，直观的说就是一个data属性值在一个视图模版中被应用了多次，甚至可能一个data属性值被当作组件的传参，在多层父子组件之间层层递传。这些复杂的逻辑，难道都要在一个订阅者(Watcher)实例中去实现吗？ 这时候Vue又引入了一个概念，依赖管理器(Dep)。我们可以将data与视图层之间的关系称之为依赖关系，data与每个视图节点的关系，可以看作是一个依赖，包括data在每一层组件之间的传递，也是一个依赖。 一个订阅者(Watcher)实例对应一个依赖管理器(Dep)。这样的好处在于，我们可以将订阅者(Watcher)与其对应的依赖关系进行解耦，不必说每当订阅者(Watcher)多了一个依赖关系的时候，又要跑到订阅者(Watcher)内部去做相关的变更。 这下新的问题又来了，我们如何去收集每个订阅者(Watcher)对应的依赖关系呢？直观的说就是一个data属性值在多少个视图层中被应用了？在每个视图层被应用了多少次？为了收集这些依赖关系，我们又需要一个新的概念，解析器(Compile)。 解析器(Compile)负责两件事情： 解析模板指令，并替换模板数据，初始化视图； 将模板指令对应的节点绑定对应的更新函数，初始化相应的订阅器； 即，解析器(Compile)可以帮助我们识别哪些是订阅者(Watcher)（初始化订阅者实例），并且解析每个订阅者(Watcher)与视图层之间的依赖关系（初始化依赖管理器），让每个订阅者(Watcher)都有一份订阅图谱（即每个订阅者实例对应一个依赖管理器实例）。当劫持到数据变更时，setter勾子会通知到依赖管理器(Dep)，依赖管理器(Dep)会遍历内部的依赖关系，针对每一条依赖关系去通知订阅者(Watcher)；而订阅者(Watcher)和视图层(View)是绑定关系，通过依赖管理器(Dep)提供的依赖关系，我们就可以去更新具体的视图层(View)。 以下是上述概念的关系图： 以上就是我对Vue双向绑定的设计思想的见解。或有纰漏之处，仅供参考。 参考链接： 0 到 1 掌握：Vue 核心之数据双向绑定","link":"/2021/02/16/vue-binding/"},{"title":"vuex和redux的区别","text":"流向vuex的流向 同步操作： view -&gt; commit -&gt; mutations -&gt; state变化 -&gt; view变化 异步操作：view -&gt; dispatch -&gt; actions -&gt; mutations -&gt; state变化 -&gt; view变化 redux的流向同步异步一样：view -&gt; actions -&gt; reducer -&gt; state变化 -&gt; view变化 Redux相对于Flux的改进 把store和dispatcher合并，结构更加简单清晰。新增state角色，代表每个时间点store对应的值，最状态的管理更加明确； 整个数据管理框架只有一个store Vuex与Redux的区别 改进了redux中的action和reducer函数，以mutations变化函数取代了reducer，无需switch，只需要在对应的mutations函数里改变state值的变化； 由于vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的state即可； vuex数据流的顺序是：view调用store.commit提交对应的请求到store中对应的mutation函数 -&gt; store更新（vue检测到数据变化自动渲染）","link":"/2020/07/23/vuex-redux/"},{"title":"Web性能优化之webp","text":"本该是加载崩溃的页面，却因为一个图片格式发生了巨大的变化。是什么使得它的加载速度提升如此之快？敬请收看技术在线，一个图片格式提升的性能！ 书接上文，在服务端开启了gzip之后，我的博客网页加载时间并没有发生太大的改变，在此先回顾一下惨不忍睹的网页参数： 36 requests 23.5 MB transferred 24.2 MB resources Finish: 2.8 min DOMContentLoaded: 1.70 s Load: 2.8 min 上文提到，虽然开启了gzip，但gzip并未对图片类型的文件做任何处理，而导致网页加载慢的罪魁祸首正是太多太大的图片资源。 难道就这么听之任之吗？ 不！使用webp格式来拯救一下！ 什么是webp？ webp是由google于2010年推出的图片格式，其目的是在保持与jpg相同的图片质量条件下，减少文件体积。 可以简单理解为是google推出的图片格式，正如apple推出的HEIF格式一样，都是为了在保持同质前提下，尽可能的减少图片体积。 简单看看我使用70%质量压缩后的图片体积变化： 原文件: 7.4MB 压缩文件: 98kb 啊！这是真实存在的吗？ 不过在全部替换之前，有必要说一下webp兼容性问题。 之前已经说了，webp是由google公司发布的，而apple又是出了名的特立独行的。在ios14和macos bigsur后，ios和macos正式支持webp格式。也就是在这个版本后的apple设备，可以大胆使用webp了。而在此之前的远古产品呢？我们可以使用很简单的方法去测试设备是否支持wbep，对于不支持的设备，依然采用jpg或则png等图片格式代替（所以服务器要准备两种格式的图片资源）。 如何检测呢？ 在此说一个最简单的方法： 1234567(function () { try { return document.createElement('canvas').toDataURL('image/webp', 0.5).indexOf('data:image/webp') === 0; } catch(err) { return false; }})() 其原理是使用canvas来导出图片，对于不支持webp格式的浏览器，toDataURL('image/webp', 0.5)导出的url是data:image/png。所以只需要判断indexOf('data:image/webp') === 0及可。 说了这么多，把图片格式都换成webp之后，网页性能如何呢？ 看看更换图片格式后的网页参数： 41 requests 1.8 MB transferred 2.6 MB resources Finish: 6.49 s DOMContentLoaded: 712 ms Load: 6.36 s 事了拂衣去，深藏功与名。","link":"/2021/03/28/webp/"},{"title":"UDP和TCP","text":"UDP和TCP都属于TCP/IP族群协议，在TCP/IP概念层模型中同属于传输层。 UDPUDP具备以下特点： 面向无连接 有单播、多播、广播功能 面向报文 不可靠性 头部开支小，传输效率高 接下来详细解释一下上述特点。 面向无连接UDP在发送数据前，并不会像TCP一样先通过三次握手来建立通信连接，然后再发送数据，而是直接发送。并且不会对数据报文做任何才分和拼接操作。 就好比一个不负责任的快递员，在派送快点前并不会提前跟你联系，甚至不确保你是否在家，他只需要把你的快递原封不动的送到你家门口即可。 单拨、多拨、广播功能UDP支持一对一、一对多、多对多、多对一等传输方式，即单拨、多拨、广播功能。 单拨，只对收发数据的特定主机进行处理，就好比你拥有自己的专属快递员，虽然他在派送快递前不需要跟你提前联系，但他每次只派送你的快递，而且只到达你的收件地址； 广播，广播与单拨的区别是IP地址不同，广播使用的广播地址是255.255.255.255，将消息发送到同一广播网络上的每个主机。就好比一个快递员，以小区为单位进行快递派送，他将快递派送到小区内，理论上每个小区业主都能收到快递（假设每个小区业主都有快递）。 多播，也称为组播，将网络中同一业务类型主机进行逻辑分组，进行数据收发时其数据仅仅在同一组中进行，其他主机没有加入此分组不能收发对应的数据。之所以将其放在广播之后介绍，是因为它和广播的概念比较容易混淆，看起来都是一对多。但是广播是基于IP地址分组，就好比快递员将快递按照小区作为单位进行派送，而多播是基于业务类型进行分组，就好比快递员将快递类型分为文件、生活用品、电子产品等分组，收件人可以申请加入指定分组，比如电子产品组，那么只有在派发电子产品组的快递时，该分组的收件人才能收到快递，而在派送其他分组的快递时，电子产品组的收件人是无法收到快递的。 面向报文发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。 我理解的是就好比快递员只以收到的快递个体为单位进行派送，他不会因为这个快递太大，而拆分成多个小的快递派发到你手上，也不会因为你同时有多个小快递，然后他把这些小快递统一打包后再派发个你。（理解不一定准确，希大神指点） 不可靠性不可靠性体现在三个方面： 无连接。想想快递员在派送快递时，甚至不需要提前跟你联系，这当然是不可靠的，谁都可以充当快递员，你也可能压根就不在家。 无备份。快递员在收到你的快递时，直接就给你派送了，这个环节是没有备份的；而且就像上边说的一样，你可能压根就不在家里签收，所以当快递丢失时，是无法找回的。 无拥塞机制。暂且理解为快递员以恒定速率往你家派发快递，他并不关心你家快递的堆积情况，有可能你家快递已经堆积如山了，他还在往里投放，这种情况下就会导致快递丢失（因为已经没有空间投放了）。 头部开支小，传输效率高UDP头部包含以下几个数据： 两个十六位的端口号，分别为源端口和目标端口； 整个数据报文的长度； 真个数据报文的检验，该字段用于发现头部信息和数据中的错误； 因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 TCPTCP具备以下特点： 面向连接 仅支持单播传输 面向字节流 可靠传输 拥塞机制 全双工通信 接下来详细解释一下上述特点。 面向连接面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。 用飞行员向塔台通信的场景来解释： 飞行员：“塔台塔台，这里是01，请求通话。”塔台： “01，收到，这里是塔台接线员02。”飞行员：“02，收到。”… …然后开始通信内容。 仅支持单播传输每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。 就好比飞行员01和塔台接线员02的通讯，是一对一的，期间不允许其他人接入。 面向字节流TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。 可靠传输与UDP相对的是，可靠性也体现在三个方面： 面向连接； 丢包重传； 拥塞机制； 面向连接上文已经解释了，在此不再赘述。拥塞机制是指当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。 重点说一下丢包重传。 TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。 如上述的飞行员向塔台通信的场景，当飞行员首次向塔台发出信息时，说明了自己的身份“01”，这个就像是客户端和服务端的第一次握手，发送了一个SYN1标识；当塔台收到飞行员的信息，回应的时候会重复飞行员的身份“01”，这是为了说明自己已经准确收到飞行员发来的信息了，同时还会说明自己发的身份“02”，这个就像是服务端向客户端响应时的第二次握手，发送一个ACK1标识，作为SYN1的应答，同时附带一个SYN2，作为当前身份的标识；当客户端收到SYN2后，需要再向客户端发送ACK2，作为SYN2的应答，这个就是第三次握手。 在每次你来我往的过程中，有一个默认的等待时间，称为RTT，在一个RTT时间内，没有收到相关的应答，比如客户端发送了SYN1标识，却没有收到服务端发来的ACK1应答，那么我们就会认为服务端没有收到SYN1，所以带有SYN1标识的数据包，就会重新传输。 这就是丢包重传的机制。 全双工通信假设客户端和服务端都有两台手机，其中一台只能打进来，另外一台只能打出去（原谅我这个奇怪的设定）。为了方便描述，我们将客户端的两台手机称为A1和A2，服务端的两台手机称为B1和B2。 客户端想要跟服务端断开连接了，于是使用A1拨打电话，发出FIN1指令，服务端使用B1接听电话后，收到了FIN1指令，发出对于FIN1的响应ACK1，于是把B1手机关闭；完后再使用B2手机向客户端拨通电话，发送FIN2指令，“B1手机已经关闭了，B2也即将关闭”，客户端收到FIN2指令后，发出ACK2响应，“好的，你把B2关掉吧”；服务端收到ACK2响应后，关闭B2手机，在约定时间内，如果客户端没有再收到服务端发来的任何消息，就默认服务端已经关闭，于是把自己的A2手机也关闭，至此，客户端和服务端的两台手机均已关闭，彻底断开连接。 这就是断开连接需要四次挥手的原因。 总结 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞机制 可靠传输，使用流量控制和拥塞机制，及重传机制 连接对象个数 支持一对一，一对多，多对一和多对多通信 只能一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅8字节 首部开销最小20字节，最大60字节 适用场景 实时通讯，如IP电话、视频会议、直播等 适用要求可靠传输的应用，如文件传输 参考链接： 一文搞懂TCP和UDP的区别 UDP单播、广播和多播","link":"/2021/05/18/udp-tcp/"},{"title":"CSS变量","text":"自定义属性，又称CSS变量或联级变量，它包含的值可以在整个文档中重复使用。 使用方式 使用--符号定义变量 使用var()方法调用变量 实例： 123456:root { --main-bg-color: #ffffff}element { background-color: var(--main-bg-color)} Tips 变量名区分大小写 变量一般定义在根伪类:root下，方便全局使用 自定义属性的继承性自定义属性可以被继承，其继承方式和CSS继承规则保持一致。 自定义属性的备用值在使用var()方法调用自定义属性值时，可传入第二个参数作为备用值。当第一个参数值失效时，会自动使用第二个参数值。 实例： 1234element { color: var(--my-color, red); background-color: var(--my-color, var(--my-bg-color, red))} Tips 备用值不是用于实现浏览器兼容性问题，如果浏览器不支持CSS自定义属性，备用值也没有用 var()方法仅支持两个参数，无法平铺展开多个备用值，但可以通过嵌套的方式实现多个备用值 在JS中使用在JS中获取和使用CSS变量，与操作普通CSS属性一样。 实例: 1234// 获取 CSS 变量element.style.getPropertyValue('--my-color')// 设置 CSS 变量element.style.setProperty('--my-color', 'red') 参考链接： 使用CSS自定义属性（变量）","link":"/2021/05/20/css-variable/"}],"tags":[{"name":"this","slug":"this","link":"/tags/this/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"webpack5","slug":"webpack5","link":"/tags/webpack5/"},{"name":"asset-module","slug":"asset-module","link":"/tags/asset-module/"},{"name":"async&#x2F;await","slug":"async-await","link":"/tags/async-await/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"BFC","slug":"BFC","link":"/tags/BFC/"},{"name":"闭包","slug":"闭包","link":"/tags/%E9%97%AD%E5%8C%85/"},{"name":"拷贝","slug":"拷贝","link":"/tags/%E6%8B%B7%E8%B4%9D/"},{"name":"decator","slug":"decator","link":"/tags/decator/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"diff","slug":"diff","link":"/tags/diff/"},{"name":"event-loop","slug":"event-loop","link":"/tags/event-loop/"},{"name":"flex","slug":"flex","link":"/tags/flex/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"gzip","slug":"gzip","link":"/tags/gzip/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"队头阻塞","slug":"队头阻塞","link":"/tags/%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E/"},{"name":"继承","slug":"继承","link":"/tags/%E7%BB%A7%E6%89%BF/"},{"name":"intersection","slug":"intersection","link":"/tags/intersection/"},{"name":"滚动加载","slug":"滚动加载","link":"/tags/%E6%BB%9A%E5%8A%A8%E5%8A%A0%E8%BD%BD/"},{"name":"webpack-plugin","slug":"webpack-plugin","link":"/tags/webpack-plugin/"},{"name":"MutationObserver","slug":"MutationObserver","link":"/tags/MutationObserver/"},{"name":"水印不可删除","slug":"水印不可删除","link":"/tags/%E6%B0%B4%E5%8D%B0%E4%B8%8D%E5%8F%AF%E5%88%A0%E9%99%A4/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"yarn","slug":"yarn","link":"/tags/yarn/"},{"name":"preflight","slug":"preflight","link":"/tags/preflight/"},{"name":"计算机","slug":"计算机","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"reflect","slug":"reflect","link":"/tags/reflect/"},{"name":"路由","slug":"路由","link":"/tags/%E8%B7%AF%E7%94%B1/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"排序","slug":"排序","link":"/tags/%E6%8E%92%E5%BA%8F/"},{"name":"单点登录","slug":"单点登录","link":"/tags/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"},{"name":"virtual dom","slug":"virtual-dom","link":"/tags/virtual-dom/"},{"name":"双向绑定","slug":"双向绑定","link":"/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A/"},{"name":"webp","slug":"webp","link":"/tags/webp/"},{"name":"tcp","slug":"tcp","link":"/tags/tcp/"},{"name":"udp","slug":"udp","link":"/tags/udp/"},{"name":"css变量","slug":"css变量","link":"/tags/css%E5%8F%98%E9%87%8F/"}],"categories":[{"name":"JS基础","slug":"JS基础","link":"/categories/JS%E5%9F%BA%E7%A1%80/"},{"name":"工程化","slug":"工程化","link":"/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"},{"name":"Web性能优化","slug":"Web性能优化","link":"/categories/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"教程","slug":"教程","link":"/categories/%E6%95%99%E7%A8%8B/"},{"name":"HTTP","slug":"HTTP","link":"/categories/HTTP/"},{"name":"Web开发技术","slug":"Web开发技术","link":"/categories/Web%E5%BC%80%E5%8F%91%E6%8A%80%E6%9C%AF/"},{"name":"http","slug":"http","link":"/categories/http/"},{"name":"计算机","slug":"计算机","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"}]}